<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Always Be Coding</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Always Be Coding">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Always Be Coding">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Always Be Coding">
  
    <link rel="alternate" href="/atom.xml" title="Always Be Coding" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Always Be Coding</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-requireAndAssert" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/02/requireAndAssert/" class="article-date">
  <time datetime="2018-08-02T10:16:29.000Z" itemprop="datePublished">2018-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/02/requireAndAssert/">Solidity 中Require(), Assert(), Revert()的用法和区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Solidity0.4.10之前，if…throw普遍利用于判断一个条件是否满足，如果不满足则终断运行。但这throw了之后它会撤回所有的状态转变，用光你所有的gas，所以这并不是一个好的操作。</p>
<p>之后，assert(), require(), and revert() 三个函数代替了if…throw的功能，并对gas有了更好的处理。原文章中提到的例子：</p>
<p>if(msg.sender != owner) { revert(); }</p>
<p>assert(msg.sender == owner);</p>
<p>require(msg.sender == owner);</p>
<p>这三个函数在功能上是与if(msg.sender != owner) { throw; }是等价的。下面具体说说这三个函数的区别。</p>
<h3 id="Require-and-assert"><a href="#Require-and-assert" class="headerlink" title="Require and assert"></a>Require and assert</h3><p>同样作为判断一个条件是否满足的函数，require会退回剩下的gas，而assert会烧掉所有的gas。对于两个函数应该在什么情况下使用，这里引用一段原文：</p>
<blockquote>
</blockquote>
<p>”The require function should be used to ensure valid conditions, such as inputs, or contract state variables are met, or to validate return values from calls to external contracts. If used properly, analysis tools can evaluate your contract to identify the conditions and function calls which will reach a failing assert. Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix.“</p>
<blockquote>
</blockquote>
<h3 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h3><p>revert的用法和throw很像，也会撤回所有的状态转变。但是它有两点不同：</p>
<ol>
<li><p>它允许你返回一个值；</p>
</li>
<li><p>它会把所有剩下的gas退回给caller</p>
</li>
</ol>
<p>调用起来就像这样子：</p>
<p>revert(‘Something bad happened’);</p>
<p>require(condition, ‘Something bad happened’);</p>
<h3 id="适合用Require的时候："><a href="#适合用Require的时候：" class="headerlink" title="适合用Require的时候："></a>适合用Require的时候：</h3><p>验证一个用户的输入是否合法：ie. require(input&lt;20);</p>
<p>验证一个外部协议的回应：require(external.send(amount));</p>
<p>判断执行一段语句的前置条件： ie. require(block.number &gt; SOME_BLOCK_NUMBER) or require(balance[msg.sender]&gt;=amount)；</p>
<p>require应该被最常使用到；</p>
<p>一般用于函数的开头处。</p>
<h3 id="适合用Revert的时候："><a href="#适合用Revert的时候：" class="headerlink" title="适合用Revert的时候："></a>适合用Revert的时候：</h3><p>和require（）应用场景差不多，适合用在逻辑复杂的情况下。</p>
<h3 id="适合用Assert的时候："><a href="#适合用Assert的时候：" class="headerlink" title="适合用Assert的时候："></a>适合用Assert的时候：</h3><p>检查有没有上溢或者是下溢： ie. c = a+b; assert(c &gt; b)</p>
<p>检查常数： ie. assert(this.balance &gt;= totalSupply);</p>
<p>在完成变化后检查状态</p>
<p>避免本不应该发生的情况出现，如程序的bug</p>
<p>assert不应该被经常利用到；</p>
<p>一般用于函数结尾处</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/02/requireAndAssert/" data-id="cjkcernlp0022av8o8nx1m58x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ethereum/">ethereum</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-solidity中constantpureview的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/01/solidity中constantpureview的区别/" class="article-date">
  <time datetime="2018-08-01T10:49:19.000Z" itemprop="datePublished">2018-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/01/solidity中constantpureview的区别/">solidity中constantpureview的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Solidity中constant、view、pure三个函数修饰词的作用是告诉编译器，函数不改变/不读取状态变量，这样函数执行就可以不消耗gas了（是完全不消耗！），因为不需要矿工来验证。所以用好这几个关键词很重要，不言而喻，省gas就是省钱！</p>
<p>这三个关键词有什么区别和联系，简单来说，在Solidity v4.17之前，只有constant，后来有人嫌constant这个词本身代表变量中的常量，不适合用来修饰函数，所以将constant拆成了view和pure。view的作用和constant一模一样，可以读取状态变量但是不能改；pure则更为严格，pure修饰的函数不能改也不能读状态变量，否则编译通不过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract constantViewPure&#123;</span><br><span class="line">    string name;</span><br><span class="line">    uint public age;</span><br><span class="line">    </span><br><span class="line">    function constantViewPure() public&#123;</span><br><span class="line">        name = &quot;lixin&quot;;</span><br><span class="line">        age = 29;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function getAgeByConstant() public constant returns(uint)&#123;</span><br><span class="line">        age += 1;  //声明为constant，在函数体中又试图去改变状态变量的值，编译会报warning, 但是可以通过</span><br><span class="line">        return age;  // return 30, 但是！状态变量age的值不会改变，仍然为29！</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    function getAgeByView() public view returns(uint)&#123;</span><br><span class="line">        age += 1; //view和constant效果一致，编译会报warning，但是可以通过</span><br><span class="line">        return age; // return 30，但是！状态变量age的值不会改变，仍然为29！</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function getAgeByPure() public pure returns(uint)&#123;</span><br><span class="line">        return age; //编译报错！pure比constant和view都要严格，pure完全禁止读写状态变量！</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/01/solidity中constantpureview的区别/" data-id="cjkcernlq0025av8o6ghh6v8n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ethereum/">ethereum</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-solidity中storage与memory区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/01/solidity中storage与memory区别/" class="article-date">
  <time datetime="2018-07-31T16:28:49.000Z" itemprop="datePublished">2018-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/01/solidity中storage与memory区别/">solidity中storage与memory区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="storage-与-memory-关键字的作用"><a href="#storage-与-memory-关键字的作用" class="headerlink" title="storage 与 memory 关键字的作用"></a>storage 与 memory 关键字的作用</h3><p>在区块链里，区块链本身就是一个数据库。如果你使用区块链标记物产的所有权，<br>归属信息将会被记录到区块链上，所有人都无法篡改，以标明不可争议的拥有权。<br>在solidity编程中，有一个数据位置的属性用来标识变量是否需要持久化到区块链中。<br>我们可以通过 —— storage 或 memory 这两个关键字来存储变量</p>
<p>###storage 与 memory 修饰的变量的区别<br>默认情况下，全局点状态变量会保存到区块链上，局部到变量保存在内存当中<br>storage修饰的变量是指永久存储在区块链中的变量。<br>Memory修饰变量则是临时的，当外部函数对某合约调用完成时，内存型变量即被移除。<br>你可以把它想象成存储在你电脑的硬盘或是RAM中数据的关系。<br>但是在很多时候你都用不到这些关键字，默认情况下 Solidity 会自动处理它们。<br>但是很多时候也需要我们进行一些特殊处理,下面我们通过代码来看一下.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">contract Person &#123;</span><br><span class="line">  struct Person &#123;</span><br><span class="line">    string name;</span><br><span class="line">    string sex;</span><br><span class="line">  &#125;</span><br><span class="line">  Person[] persons;</span><br><span class="line">  function eatSandwich(uint _index) public &#123;</span><br><span class="line">    // Person person = persons[_index];</span><br><span class="line">    // ^ 看上去很直接，不过 Solidity 将会给出警告</span><br><span class="line">    // 告诉你应该明确在这里定义 `storage` 或者 `memory`。</span><br><span class="line">    // 所以你应该明确定义 `storage`:</span><br><span class="line">    Person storage myPerson = persons[_index];</span><br><span class="line">    // ...这样 `mySandwich` 是指向 `sandwiches[_index]`的指针</span><br><span class="line">    // 在存储里，另外...</span><br><span class="line">    myPerson.sex = &quot;女!&quot;;</span><br><span class="line">    // ...这将永久把 `sandwiches[_index]` 变为区块链上的存储</span><br><span class="line"></span><br><span class="line">    // 如果你只想要一个副本，可以使用`memory`:</span><br><span class="line">    Person memory anotherPerson = persons[_index + 1];</span><br><span class="line">    // ...这样 `anotherSandwich` 就仅仅是一个内存里的副本了</span><br><span class="line">    // 另外</span><br><span class="line">    anotherPerson.sex = &quot;Eaten!&quot;;</span><br><span class="line">    // ...将仅仅修改临时变量，对 `sandwiches[_index + 1]` 没有任何影响</span><br><span class="line">    // 不过你可以这样做:</span><br><span class="line">    persons[_index + 1] = anotherPerson;</span><br><span class="line">    // ...如果你想把副本的改动保存回区块链存储</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上代码，我们就可以在某些场合下也需要你显式地声明 storage 或 memory了！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/01/solidity中storage与memory区别/" data-id="cjkcernlr0027av8oedlw3i2j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ethereum/">ethereum</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="solidity中storage与memory-区别" class="article article-type-solidity中storage与memory" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/01/区别/" class="article-date">
  <time datetime="2018-07-31T16:22:54.000Z" itemprop="datePublished">2018-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/01/区别/">区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/01/区别/" data-id="cjkcernm1002pav8oo7tfs2qx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-比特币区块为什么是1M大小？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/29/比特币区块为什么是1M大小？/" class="article-date">
  <time datetime="2018-07-29T04:57:45.000Z" itemprop="datePublished">2018-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/29/比特币区块为什么是1M大小？/">比特币区块为什么是1M大小？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>了解比特币的人都知道，比特币区块大小只有 1M，但是有没有人想过，为什么当初只设定了 1M，而不是 512K，也不是 2M 或者 8M 呢？</p>
<h2 id="初始"><a href="#初始" class="headerlink" title="初始"></a>初始</h2><p>其实一开始中本聪就把区块设计成最大可支持 32M 容量，为的就是防止以后单个区块容量不能满足使用，可见其远见！</p>
<h3 id="那为什么后来只当初的上限只设了-1M-呢？"><a href="#那为什么后来只当初的上限只设了-1M-呢？" class="headerlink" title="那为什么后来只当初的上限只设了 1M 呢？"></a>那为什么后来只当初的上限只设了 1M 呢？</h3><p>在 2009 年，比特币在刚被创造出来的时候，并没有大功率的矿机来计算挖矿，只能通过普通电脑的 CPU 进行打包，而且当初计算机的 CPU 算力也极其有限。加上使用的用户非常少，所以当时被打包好的区块平均大小在 1~2K 左右。</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul>
<li>保证全网节点足够多</li>
</ul>
<p>比特币网络为什么安全且不可篡改呢？</p>
<p>除了有极其多的算力相互制衡之外，那就是比特币的全网节点了，也就是每一个区块。这些区块除了保存每一条交易信息和验证交易之外，还能保障比特币网络的安全。</p>
<p>当时的开发团队就有人认为如果区块设定太大的话，在进行数据打包的过程中，会导致普通计算机 CPU 超负荷计算，加之当时的比特币价格很低，长此以往，不利于更多矿工的加入。</p>
<p>如果区块太大的话，就可能导致普通计算机无法运行全节点，这样的话，全节点就会变得只有少数 CPU 较高的计算机或者专业的矿机才能运行，最后就只会导致算力的中心化，降低矿工的作恶成本，反而会对比特币不利！</p>
<p>加上如果区块过大的话，如果出现 DDoS 攻击，会消耗掉大量的算力，让真正的交易订单无法进行打包处理，造成网络的严重拥堵！</p>
<ul>
<li>电脑验证交易的速度</li>
</ul>
<p>如果用现在普通的电脑来打包记录一个大小为 1M 的区块，那么从开始验证到结束大约需要 30 秒，但是如果是需要验证一个 2M 的区块，可能就需要高达 10 分钟，这个时间是极其漫长的，因为在这段时间内，黑客可以做很多事情！</p>
<p>理论上来说，黑客可以根据这个延时，对比特币网络进行攻击。为了避免这种攻击，所以在当时最佳的选择就是让每个区块都在 1M 大小左右！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/29/比特币区块为什么是1M大小？/" data-id="cjkcernm70030av8orkd140vf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bitcoin/">bitcoin</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-智能合约基本中的基本元素" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/28/智能合约基本中的基本元素/" class="article-date">
  <time datetime="2018-07-28T15:53:41.000Z" itemprop="datePublished">2018-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/28/智能合约基本中的基本元素/">智能合约源文件的基本要素概览</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>合约类似面向对象语言中的类。</li>
<li>支持继承</li>
</ul>
<p>每个合约中可包含状态变量(State Variables)，函数(Functions),函数修饰符（Function Modifiers）,事件（Events）,结构类型(Structs Types)和枚举类型(Enum Types)。</p>
<h3 id="状态变量（State-Variables）"><a href="#状态变量（State-Variables）" class="headerlink" title="状态变量（State Variables）"></a>状态变量（State Variables）</h3><p>变量值会永久存储在合约的存储空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// simple store example</span><br><span class="line"></span><br><span class="line">contract simpleStorage&#123;</span><br><span class="line"></span><br><span class="line">    uint valueStore; //state variable</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数（Functions）<br>智能合约中的一个可执行单元。</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract simpleMath&#123;</span><br><span class="line">    //Simple add function,try a divide action?</span><br><span class="line">    function add(uint x, uint y) returns (uint z)&#123;</span><br><span class="line">        z = x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述示例展示了一个简单的加法函数。</p>
<p>函数调用可以设置为内部（Internal）的和外部（External）的。同时对于其它合同的不同级别的可见性和访问控制(Visibility and Accessors)。具体的情况详见后面类型中关于函数的章节。</p>
<h3 id="函数修饰符-Function-Modifiers"><a href="#函数修饰符-Function-Modifiers" class="headerlink" title="函数修饰符(Function Modifiers)"></a>函数修饰符(Function Modifiers)</h3><h3 id="事件（Events）"><a href="#事件（Events）" class="headerlink" title="事件（Events）"></a>事件（Events）</h3><p>事件是以太坊虚拟机(EVM)日志基础设施提供的一个便利接口。用于获取当前发生的事件。</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    event aNewHigherBid(address bidder, uint amount);</span><br><span class="line">    </span><br><span class="line">    function  bid(uint bidValue) external &#123;</span><br><span class="line">        aNewHigherBid(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Home &#123;</span><br><span class="line">    enum Switch&#123;On,Off&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体类型（Structs-Types）"><a href="#结构体类型（Structs-Types）" class="headerlink" title="结构体类型（Structs Types）"></a>结构体类型（Structs Types）</h3><p>自定义的将几个变量组合在一起形成的类型。详见关于结构体相关章节。</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Company &#123;</span><br><span class="line">    //user defined `Employee` struct type</span><br><span class="line">    //group with serveral variables</span><br><span class="line">    struct employee&#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint age;</span><br><span class="line">        uint salary;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //User defined `manager` struct type</span><br><span class="line">    //group with serveral variables</span><br><span class="line">    struct manager&#123;</span><br><span class="line">        employee employ;</span><br><span class="line">        string title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/28/智能合约基本中的基本元素/" data-id="cjkcernm80033av8orzst4g3p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ethereum/">ethereum</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-truffle安装以及基本指令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/26/truffle安装以及基本指令/" class="article-date">
  <time datetime="2018-07-26T15:22:05.000Z" itemprop="datePublished">2018-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/26/truffle安装以及基本指令/">truffle安装以及基本指令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>linux下安装方式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g truffle</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建工程：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir testdir</span><br><span class="line"></span><br><span class="line">　$ cd testdir</span><br><span class="line"></span><br><span class="line">　$　truffle init</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分别是 创建testdir目录， 进入testdir目录，  创建一个truffle工程</span><br></pre></td></tr></table></figure>
<p> contracts/ - Truffle 默认的合约文件存放地址。</p>
<p> migrations/ - 存放发布脚本文件</p>
<p> test/ - 用来测试应用和合约的测试文件</p>
<p> truffle.js - Truffle 的配置文件 </p>
<p>3.编译工程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　truffle compile</span><br></pre></td></tr></table></figure>
<p>编译的输出位于 build/contarcts 目录</p>
<p>4.执行移植 :  (移植是由一些Javascript文件组成来协助发布到以太坊网络)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle migrate</span><br></pre></td></tr></table></figure>
<p>这个命令会执行所有的位于migrations目录内的移植脚本。如果你之前的移植是成功执行的。truffle migrate仅会执行新创建的移植。如果没有新的移植脚本，这个命令不同执行任何操作。可以使用选项–reset来从头执行移植脚本。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/26/truffle安装以及基本指令/" data-id="cjkcernlx002gav8olmcwmgp9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ethererum/">ethererum</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-go-test初体验" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/24/go-test初体验/" class="article-date">
  <time datetime="2018-07-24T14:21:03.000Z" itemprop="datePublished">2018-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/24/go-test初体验/">go_test初体验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>go test 功能，提高了开发和测试的效率。<br>有时会遇到这样的场景：<br>进行测试之前需要初始化操作(例如打开连接)，测试结束后，需要做清理工作(例如关闭连接)等等。这个时候就可以使用TestMain()。</p>
<p>下面例子的文件结构如下：</p>
<p>hello/add.go<br>hello/test_add.go</p>
<h3 id="add-go文件"><a href="#add-go文件" class="headerlink" title="add.go文件"></a>add.go文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package hello</span><br><span class="line"></span><br><span class="line">func Add(a,b int) int &#123;</span><br><span class="line"></span><br><span class="line">    return a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add_test.go文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package hello</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line"></span><br><span class="line">        r := Add(1, 2)</span><br><span class="line">        if r !=3 &#123;</span><br><span class="line"></span><br><span class="line">                t.Errorf(&quot;Add(1, 2) failed. Got %d, expected 3.&quot;, r)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func TestMain(m *testing.M) &#123;</span><br><span class="line">    fmt.Println(&quot;begin&quot;)</span><br><span class="line">    m.Run()</span><br><span class="line">    fmt.Println(&quot;end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试从TestMain进入，依次执行测试用例，最后从TestMain退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test –v</span><br></pre></td></tr></table></figure>
<h3 id="output"><a href="#output" class="headerlink" title="output:"></a>output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin </span><br><span class="line">=== RUN TestAdd </span><br><span class="line">— PASS: TestAdd (0.00s) </span><br><span class="line">PASS </span><br><span class="line">end </span><br><span class="line">ok hello 0.432s</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/24/go-test初体验/" data-id="cjkcernlk001sav8op2qxgov1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-GoroutineAndChannel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/21/GoroutineAndChannel/" class="article-date">
  <time datetime="2018-07-21T14:17:11.000Z" itemprop="datePublished">2018-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/21/GoroutineAndChannel/">GoroutineAndChannel</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Go语言的主要的功能在于令人简易使用的并行设计，这个方法叫做Goroutine，通过Goroutine能够让你的程序以异步的方式运行，而不需要担心一个函数导致程序中断，因此Go语言也非常地适合网络服务。</p>
<p>我们通过go让其中一个函数同步运行，如此就不需要等待该函数运行完后才能运行下一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // 通过 `go`，我们可以把这个函数异步执行，这样就不会阻塞往下执行。</span><br><span class="line">    go loop()</span><br><span class="line">    // 执行 Other</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Goroutine是类似线程的概念（但Goroutine并不是线程）。线程属于系统层面，通常来说创建一个新的线程会消耗较多的资源且管理不易。而 Goroutine就像轻量级的线程，但我们称其为并发，一个Go程序可以运行超过数万个 Goroutine，并且这些性能都是原生级的，随时都能够关闭、结束。一个核心里面可以有多个Goroutine，通过GOMAXPROCS参数你能够限制Gorotuine可以占用几个系统线程来避免失控。</p>
<p>在内置的官方包中也不时能够看见Goroutine的应用，像是net/http中用来监听网络服务的函数实际上是创建一个不断运行循环的Goroutine。</p>
<h3 id="设置同时执行的cpu数（GOMAXPROCS）"><a href="#设置同时执行的cpu数（GOMAXPROCS）" class="headerlink" title="设置同时执行的cpu数（GOMAXPROCS）"></a>设置同时执行的cpu数（GOMAXPROCS）</h3><p>GOMAXPROCS 在调度程序优化后会去掉，默认用系统所有资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    num := runtime.NumCPU()    //本地机器的逻辑CPU个数</span><br><span class="line">    runtime.GOMAXPROCS(num)    //设置可同时执行的最大CPU数，并返回先前的设置</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Goroutine中使用recover"><a href="#Goroutine中使用recover" class="headerlink" title="Goroutine中使用recover"></a>Goroutine中使用recover</h3><p>应用场景，如果某个goroutine panic了，而且这个goroutine里面没有捕获(recover)，那么整个进程就会挂掉。所以，好的习惯是每当go产生一个goroutine，就需要写下recover。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    domainSyncChan = make(chan int, 10)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func domainPut(num int) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        err := recover()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;error to chan put.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    domainSyncChan &lt;- num</span><br><span class="line">    </span><br><span class="line">    panic(&quot;error....&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        domainName := i</span><br><span class="line">        go domainPut(domainName)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second * 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Goroutine-例子"><a href="#Goroutine-例子" class="headerlink" title="Goroutine 例子"></a>Goroutine 例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    m    = make(map[int]uint64)</span><br><span class="line">    lock sync.Mutex //申明一个互斥锁</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type task struct &#123;</span><br><span class="line">    n int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func calc(t *task) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        err := recover()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;error...&quot;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    var sum uint64</span><br><span class="line">    sum = 1</span><br><span class="line">    for i := 1; i &lt; t.n; i++ &#123;</span><br><span class="line">        sum *= uint64(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock.Lock() //写全局数据加互斥锁</span><br><span class="line">    m[t.n] = sum</span><br><span class="line">    lock.Unlock() //解锁</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        t := &amp;task&#123;n: i&#125;</span><br><span class="line">        go calc(t) // Goroutine来执行任务</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second) // Goroutine异步，所以等一秒到任务完成</span><br><span class="line"></span><br><span class="line">    lock.Lock() //读全局数据加锁</span><br><span class="line">    for k, v := range m &#123;</span><br><span class="line">        fmt.Printf(&quot;%d! = %v\n&quot;, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(len(m))</span><br><span class="line">    lock.Unlock() //解锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Goroutine-例子（等待所有任务退出主程序再退出）"><a href="#Goroutine-例子（等待所有任务退出主程序再退出）" class="headerlink" title="Goroutine 例子（等待所有任务退出主程序再退出）"></a>Goroutine 例子（等待所有任务退出主程序再退出）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func calc(w *sync.WaitGroup, i int)  &#123;</span><br><span class="line">    fmt.Println(&quot;calc: &quot;, i)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    w.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    for i:=0; i&lt;10; i++ &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go calc(&amp;wg, i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(&quot;all goroutine finish&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>channel，管道、队列，先进先出，用来异步传递数据。channel加上goroutine，就形成了一种既简单又强大的请求处理模型，使高并发和线程同步之间代码的编写变得异常简单。</p>
<p>线程安全，多个goroutine同时访问，不需要加锁。</p>
<p>channel是有类型的，一个整数的channel只能存放整数。</p>
<h3 id="channel使用"><a href="#channel使用" class="headerlink" title="channel使用"></a>channel使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//chan申明</span><br><span class="line">var userChan chan interface&#123;&#125;          // chan里面放interface类型</span><br><span class="line">userChan = make(chan interface&#123;&#125;, 10)  // make初始化，大小为10</span><br><span class="line"></span><br><span class="line">var readOnlyChan &lt;-chan int            // 只读chan</span><br><span class="line">var writeOnlyChan chan&lt;- int           // 只写chan</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//chan放取数据</span><br><span class="line">userChan &lt;- &quot;nick&quot;</span><br><span class="line">name := &lt;- userChan</span><br><span class="line">name, ok := &lt;- userChan</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//关闭chan</span><br><span class="line">intChan := make(chan int, 1)</span><br><span class="line">intChan &lt;- 9</span><br><span class="line">close(intChan)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// range chan</span><br><span class="line">intChan := make(chan int, 10)</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    intChan &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">close(intChan)</span><br><span class="line"></span><br><span class="line">for v := range intChan &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="放入chan数据个数超过初始化指定大小会怎样？"><a href="#放入chan数据个数超过初始化指定大小会怎样？" class="headerlink" title="放入chan数据个数超过初始化指定大小会怎样？"></a>放入chan数据个数超过初始化指定大小会怎样？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userChan := make(chan interface&#123;&#125;)</span><br><span class="line">userChan &lt;- &quot;nick&quot;</span><br><span class="line">// 错误！fatal error: all goroutines are asleep - deadlock!</span><br><span class="line">// 开启race会一直阻塞</span><br></pre></td></tr></table></figure>
<p>开启一个goroutine来放入初始化未指定大小的chan不会报错。<br>即放即走，在等放入时有来拿数据的，就直接拿走。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">userChan := make(chan interface&#123;&#125;)</span><br><span class="line">go func() &#123;</span><br><span class="line">    userChan &lt;- &quot;nick&quot;</span><br><span class="line">&#125;()</span><br><span class="line">name := &lt;- userChan</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">userChan := make(chan interface&#123;&#125;)</span><br><span class="line">go func() &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        userChan &lt;- &quot;nick&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line">for &#123;</span><br><span class="line">    name := &lt;- userChan</span><br><span class="line">    fmt.Println(name)</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="chan关闭与不关闭"><a href="#chan关闭与不关闭" class="headerlink" title="chan关闭与不关闭"></a>chan关闭与不关闭</h3><p>关闭chan后再放入数据会 panic: send on closed channel。</p>
<p>chan不关闭取超数据的情况会报 deadlock</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    intChan := make(chan int, 10)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        intChan &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    for &#123;</span><br><span class="line">        //十次后 fatal error: all goroutines are asleep - deadlock!</span><br><span class="line">        i := &lt;- intChan</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="chan关闭的情况取超出值为类型默认值，如int为0"><a href="#chan关闭的情况取超出值为类型默认值，如int为0" class="headerlink" title="chan关闭的情况取超出值为类型默认值，如int为0"></a>chan关闭的情况取超出值为类型默认值，如int为0</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    intChan := make(chan int, 10)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        intChan &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    close(intChan)</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        i := &lt;- intChan</span><br><span class="line">        //十次后i值都为0，不报错</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断chan是否取完"><a href="#判断chan是否取完" class="headerlink" title="判断chan是否取完"></a>判断chan是否取完</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    intChan := make(chan int, 10)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        intChan &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    close(intChan)</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        i, ok := &lt;- intChan</span><br><span class="line">        if !ok &#123;</span><br><span class="line">            fmt.Println(&quot;channel is close.&quot;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="channel-例子"><a href="#channel-例子" class="headerlink" title="channel 例子"></a>channel 例子</h3><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func sendData(ch chan&lt;- string) &#123;</span><br><span class="line">    ch &lt;- &quot;go&quot;</span><br><span class="line">    ch &lt;- &quot;java&quot;</span><br><span class="line">    ch &lt;- &quot;c&quot;</span><br><span class="line">    ch &lt;- &quot;c++&quot;</span><br><span class="line">    ch &lt;- &quot;python&quot;</span><br><span class="line">    close(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getData(ch &lt;-chan string, chColse chan bool) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        str, ok := &lt;-ch</span><br><span class="line">        if !ok &#123;</span><br><span class="line">            fmt.Println(&quot;chan is close.&quot;)</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(str)</span><br><span class="line">    &#125;</span><br><span class="line">    chColse &lt;- true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan string, 10)</span><br><span class="line">    chColse := make(chan bool, 1)</span><br><span class="line">    go sendData(ch)</span><br><span class="line">    go getData(ch, chColse)</span><br><span class="line">    &lt;-chColse</span><br><span class="line">    close(chColse)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例子2-：interface类型chan，取出后转化为对应类型。"><a href="#例子2-：interface类型chan，取出后转化为对应类型。" class="headerlink" title="例子2 ：interface类型chan，取出后转化为对应类型。"></a>例子2 ：interface类型chan，取出后转化为对应类型。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type user struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    userChan := make(chan interface&#123;&#125;, 1)</span><br><span class="line"></span><br><span class="line">    u := user&#123;Name: &quot;nick&quot;&#125;</span><br><span class="line">    userChan &lt;- &amp;u</span><br><span class="line">    close(userChan)</span><br><span class="line"></span><br><span class="line">    var u1 interface&#123;&#125;</span><br><span class="line">    u1 = &lt;-userChan</span><br><span class="line"></span><br><span class="line">    var u2 *user</span><br><span class="line">    u2, ok := u1.(*user)</span><br><span class="line">    if !ok &#123;</span><br><span class="line">        fmt.Println(&quot;cant not convert.&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(u2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="channel-超时处理"><a href="#channel-超时处理" class="headerlink" title="channel 超时处理"></a>channel 超时处理</h3><p>利用select来处理chan超时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    case v := &lt;-chan1:</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    case v := &lt;-chan2:</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    default:</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(&quot;timeout...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>time.After()定时器来做处理。</p>
<p>在time.After()计时器触发之前，底层计时器不会被垃圾收集器回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case m := &lt;-c:</span><br><span class="line">    handle(m)</span><br><span class="line">case &lt;-time.After(5 * time.Minute):</span><br><span class="line">    fmt.Println(&quot;timed out&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t := time.NewTicker(time.Second)</span><br><span class="line">    fmt.Println(t)</span><br><span class="line">    for v := range t.C &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">    t.Stop()</span><br></pre></td></tr></table></figure>
<h3 id="Goroutine-Channel-例子"><a href="#Goroutine-Channel-例子" class="headerlink" title="Goroutine+Channel 例子"></a>Goroutine+Channel 例子</h3><h3 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h3><p>多个goroutine处理任务；</p>
<p>等待一组channel的返回结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">func calc(taskChan, resChan chan int, exitChan chan bool) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        err := recover()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;error...&quot;)</span><br><span class="line">            return </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    for v := range taskChan &#123;</span><br><span class="line">        // 任务处理逻辑</span><br><span class="line">        flag := true</span><br><span class="line">        for i := 2; i &lt; v; i++ &#123;</span><br><span class="line">            if v%i == 0 &#123;</span><br><span class="line">                flag = false</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if flag &#123;</span><br><span class="line">            //结果进chan</span><br><span class="line">            resChan &lt;- v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //处理完进退出chan</span><br><span class="line">    exitChan &lt;- true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    //任务chan</span><br><span class="line">    intChan := make(chan int, 1000)</span><br><span class="line">    //结果chan</span><br><span class="line">    resChan := make(chan int, 1000)</span><br><span class="line">    //退出chan</span><br><span class="line">    exitChan := make(chan bool, 8)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        for i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">            intChan &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        close(intChan)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    //启动8个goroutine做任务</span><br><span class="line">    for i := 0; i &lt; 8; i++ &#123;</span><br><span class="line">        go calc(intChan, resChan, exitChan)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        //等所有goroutine结束</span><br><span class="line">        for i := 0; i &lt; 8; i++ &#123;</span><br><span class="line">            &lt;-exitChan</span><br><span class="line">        &#125;</span><br><span class="line">        close(resChan)</span><br><span class="line">        close(exitChan)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    for v := range resChan &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h3><p>等待一组channel的返回结果 sync.WaitGroup 的解决方法。</p>
<p>WaitGroup用于等待一组线程的结束。父线程调用Add方法来设定应等待的线程的数量。每个被等待的线程在结束时应调用Done方法。同时，主线程里可以调用Wait方法阻塞至所有线程结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func merge(cs &lt;-chan int) &lt;-chan int &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    out := make(chan int)</span><br><span class="line"></span><br><span class="line">    output := func(c &lt;-chan int) &#123;</span><br><span class="line">        for n := range c &#123;</span><br><span class="line">            out &lt;- n</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Add(len(cs))</span><br><span class="line"></span><br><span class="line">    for _, c := range cs &#123;</span><br><span class="line">        go output(c)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        close(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    return out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/21/GoroutineAndChannel/" data-id="cjkcernle001fav8o71lds2vw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-构建微型区块链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/19/构建微型区块链/" class="article-date">
  <time datetime="2018-07-19T12:06:35.000Z" itemprop="datePublished">2018-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/19/构建微型区块链/">构建微型区块链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>经过一段时间对区块链理论知识的学习，了解到区块链中的每个区块的基本结构由区块头和区块体构成，并了解了其中每部分包含的结构。本文在理论学习的基础上通过Python语言动手实现一个微型的区块链系统。</p>
<p>在区块链中，每个区块都需要一个时间戳 (timestamp) 和一个可选的索引 (index)。在tinyblockchain中，我们会同时存储这两项。为了确保区块链的完整性，每个区块都需要有一个能够识别自身身份的哈希 (hash)。在比特币中，每个区块的哈希对区块索引、时间戳、数据和前一区块哈希所有内容的一个加密哈希。此外，数据可以是任何你想要存储的任何内容。</p>
<p>已经有了区块结构，但是我们构建的是一个区块链。所以，我们需要将区块添加到真正的链上。正如前文所说，每个区块都需要前一个区块的信息。如此一来，就出现了一个问题：区块链中的第一个区块是如何而来？ 第一个区块，或者一般叫做创始块(genesis block), 这是一个十分特殊的块。在很多情况下，它是通过手动或是一些特殊的逻辑添加到区块链中。</p>
<p>为简便起见，我们创建一个简单返回创世块的函数。创始块的索引为 0，有一个任意的数据值，一个属于 “前一个哈希” 参数的任意值。</p>
<p>现在我们已经创建一个创世块，接下来我们需要一个能够在区块链中生成后续区块的函数。这个函数接受区块链中的前一个区块作为参数，创建所要生成区块的数据，然后返回带有数据的新区块。当新区块对前面的区块信息进行哈希时，区块链的完整性将会得到进一步增强。如果我们不对以前的区块信息进行哈希，那么第三者就能够轻易地“篡改历史”，用一个他们自己的链替换我们的链。区块链的哈希就像是一个加密证明，它能够保证一旦一个区块被加入到区块链中，那么这个区块就永远无法被替换或者移除。</p>
<p>在我们的案例中，区块链其实仅仅是一个 Python 的列表。列表的第一个元素是创世块。当然了，我们需要增加后续区块。因为这只是一个极简的区块链模型，我们仅添加 20 个新的区块。可以通过一个循环来添加。</p>
<p>全部源码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib <span class="keyword">as</span> hasher</span><br><span class="line"><span class="keyword">import</span> datetime <span class="keyword">as</span> date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, index, timestamp, data, previous_hash)</span>:</span></span><br><span class="line">        self.index = index</span><br><span class="line">        self.timestamp = timestamp</span><br><span class="line">        self.data = data</span><br><span class="line">        self.previous_hash = previous_hash</span><br><span class="line">        self.hash = self.hash_block()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash_block</span><span class="params">(self)</span>:</span></span><br><span class="line">        sha = hasher.sha256()</span><br><span class="line">        sha.update(</span><br><span class="line">            bytes(</span><br><span class="line">                str(self.index) + str(self.timestamp) + str(self.data) + str(</span><br><span class="line">                    self.previous_hash), <span class="string">'utf-8'</span>))</span><br><span class="line">        <span class="keyword">return</span> sha.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_genesis_block</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#  Manually construct a block with index 0 and arbitrary previous hash</span></span><br><span class="line">    <span class="keyword">return</span> Block(<span class="number">0</span>, date.datetime.now(), <span class="string">"Genesis Block"</span>, <span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_block</span><span class="params">(last_block)</span>:</span></span><br><span class="line">    this_index = last_block.index + <span class="number">1</span></span><br><span class="line">    this_timestamp = date.datetime.now()</span><br><span class="line">    this_data = <span class="string">"Hey! I'm block "</span> + str(this_index)</span><br><span class="line">    this_hash = last_block.hash</span><br><span class="line">    <span class="keyword">return</span> Block(this_index, this_timestamp, this_data, this_hash)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#  Create the blockchain and add the genesis block</span></span><br><span class="line">    blockchain = [create_genesis_block()]</span><br><span class="line">    previous_block = blockchain[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  How many blocks should we add to the chain after the genesis block</span></span><br><span class="line">    num_of_blocks_to_add = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, num_of_blocks_to_add):</span><br><span class="line">        block_to_add = next_block(previous_block)</span><br><span class="line">        blockchain.append(block_to_add)</span><br><span class="line">        previous_block = block_to_add</span><br><span class="line">        <span class="comment">#  Tell everyone about it!</span></span><br><span class="line">        print(<span class="string">"Block #&#123;&#125; has been added to the "</span></span><br><span class="line">              <span class="string">"blockchain!"</span>.format(block_to_add.index))</span><br><span class="line">        print(<span class="string">"Hash: &#123;&#125;\n"</span>.format(block_to_add.hash))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行部分截图：<br><img src="http://ww1.sinaimg.cn/large/007330Aply1ftffkde631j31a00t6dq6.jpg" alt=""><br>可以看出我们的链已经如期工作了，第一条微型区块链正式完成！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/19/构建微型区块链/" data-id="cjkcernm90035av8osoyoud5h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blockchain/">blockchain</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linked-List/">Linked List</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arrays/">arrays</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bitcoin/">bitcoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blockchain/">blockchain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cryptocurrency/">cryptocurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ethererum/">ethererum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ethereum/">ethereum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hyperledger-fabric/">hyperledger-fabric</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stack-queue/">stack&&queue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tree/">tree</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/Linked-List/" style="font-size: 16.67px;">Linked List</a> <a href="/tags/arrays/" style="font-size: 20px;">arrays</a> <a href="/tags/bitcoin/" style="font-size: 11.67px;">bitcoin</a> <a href="/tags/blockchain/" style="font-size: 15px;">blockchain</a> <a href="/tags/cryptocurrency/" style="font-size: 10px;">cryptocurrency</a> <a href="/tags/ethererum/" style="font-size: 10px;">ethererum</a> <a href="/tags/ethereum/" style="font-size: 16.67px;">ethereum</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/hyperledger-fabric/" style="font-size: 10px;">hyperledger-fabric</a> <a href="/tags/leetcode/" style="font-size: 13.33px;">leetcode</a> <a href="/tags/stack-queue/" style="font-size: 11.67px;">stack&&queue</a> <a href="/tags/tree/" style="font-size: 18.33px;">tree</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/02/requireAndAssert/">Solidity 中Require(), Assert(), Revert()的用法和区别</a>
          </li>
        
          <li>
            <a href="/2018/08/01/solidity中constantpureview的区别/">solidity中constantpureview的区别</a>
          </li>
        
          <li>
            <a href="/2018/08/01/solidity中storage与memory区别/">solidity中storage与memory区别</a>
          </li>
        
          <li>
            <a href="/2018/08/01/区别/">区别</a>
          </li>
        
          <li>
            <a href="/2018/07/29/比特币区块为什么是1M大小？/">比特币区块为什么是1M大小？</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>