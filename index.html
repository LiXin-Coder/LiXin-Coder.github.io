<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Always Be Coding</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Always Be Coding">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Always Be Coding">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Always Be Coding">
  
    <link rel="alternate" href="/atom.xml" title="Always Be Coding" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Always Be Coding</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-GoroutineAndChannel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/21/GoroutineAndChannel/" class="article-date">
  <time datetime="2018-07-21T14:17:11.000Z" itemprop="datePublished">2018-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/21/GoroutineAndChannel/">GoroutineAndChannel</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Go语言的主要的功能在于令人简易使用的并行设计，这个方法叫做Goroutine，通过Goroutine能够让你的程序以异步的方式运行，而不需要担心一个函数导致程序中断，因此Go语言也非常地适合网络服务。</p>
<p>我们通过go让其中一个函数同步运行，如此就不需要等待该函数运行完后才能运行下一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // 通过 `go`，我们可以把这个函数异步执行，这样就不会阻塞往下执行。</span><br><span class="line">    go loop()</span><br><span class="line">    // 执行 Other</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Goroutine是类似线程的概念（但Goroutine并不是线程）。线程属于系统层面，通常来说创建一个新的线程会消耗较多的资源且管理不易。而 Goroutine就像轻量级的线程，但我们称其为并发，一个Go程序可以运行超过数万个 Goroutine，并且这些性能都是原生级的，随时都能够关闭、结束。一个核心里面可以有多个Goroutine，通过GOMAXPROCS参数你能够限制Gorotuine可以占用几个系统线程来避免失控。</p>
<p>在内置的官方包中也不时能够看见Goroutine的应用，像是net/http中用来监听网络服务的函数实际上是创建一个不断运行循环的Goroutine。</p>
<h3 id="设置同时执行的cpu数（GOMAXPROCS）"><a href="#设置同时执行的cpu数（GOMAXPROCS）" class="headerlink" title="设置同时执行的cpu数（GOMAXPROCS）"></a>设置同时执行的cpu数（GOMAXPROCS）</h3><p>GOMAXPROCS 在调度程序优化后会去掉，默认用系统所有资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    num := runtime.NumCPU()    //本地机器的逻辑CPU个数</span><br><span class="line">    runtime.GOMAXPROCS(num)    //设置可同时执行的最大CPU数，并返回先前的设置</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Goroutine中使用recover"><a href="#Goroutine中使用recover" class="headerlink" title="Goroutine中使用recover"></a>Goroutine中使用recover</h3><p>应用场景，如果某个goroutine panic了，而且这个goroutine里面没有捕获(recover)，那么整个进程就会挂掉。所以，好的习惯是每当go产生一个goroutine，就需要写下recover。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    domainSyncChan = make(chan int, 10)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func domainPut(num int) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        err := recover()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;error to chan put.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    domainSyncChan &lt;- num</span><br><span class="line">    </span><br><span class="line">    panic(&quot;error....&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        domainName := i</span><br><span class="line">        go domainPut(domainName)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second * 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Goroutine-例子"><a href="#Goroutine-例子" class="headerlink" title="Goroutine 例子"></a>Goroutine 例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    m    = make(map[int]uint64)</span><br><span class="line">    lock sync.Mutex //申明一个互斥锁</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type task struct &#123;</span><br><span class="line">    n int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func calc(t *task) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        err := recover()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;error...&quot;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    var sum uint64</span><br><span class="line">    sum = 1</span><br><span class="line">    for i := 1; i &lt; t.n; i++ &#123;</span><br><span class="line">        sum *= uint64(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock.Lock() //写全局数据加互斥锁</span><br><span class="line">    m[t.n] = sum</span><br><span class="line">    lock.Unlock() //解锁</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        t := &amp;task&#123;n: i&#125;</span><br><span class="line">        go calc(t) // Goroutine来执行任务</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second) // Goroutine异步，所以等一秒到任务完成</span><br><span class="line"></span><br><span class="line">    lock.Lock() //读全局数据加锁</span><br><span class="line">    for k, v := range m &#123;</span><br><span class="line">        fmt.Printf(&quot;%d! = %v\n&quot;, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(len(m))</span><br><span class="line">    lock.Unlock() //解锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Goroutine-例子（等待所有任务退出主程序再退出）"><a href="#Goroutine-例子（等待所有任务退出主程序再退出）" class="headerlink" title="Goroutine 例子（等待所有任务退出主程序再退出）"></a>Goroutine 例子（等待所有任务退出主程序再退出）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func calc(w *sync.WaitGroup, i int)  &#123;</span><br><span class="line">    fmt.Println(&quot;calc: &quot;, i)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    w.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    for i:=0; i&lt;10; i++ &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go calc(&amp;wg, i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(&quot;all goroutine finish&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>channel，管道、队列，先进先出，用来异步传递数据。channel加上goroutine，就形成了一种既简单又强大的请求处理模型，使高并发和线程同步之间代码的编写变得异常简单。</p>
<p>线程安全，多个goroutine同时访问，不需要加锁。</p>
<p>channel是有类型的，一个整数的channel只能存放整数。</p>
<h3 id="channel使用"><a href="#channel使用" class="headerlink" title="channel使用"></a>channel使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//chan申明</span><br><span class="line">var userChan chan interface&#123;&#125;          // chan里面放interface类型</span><br><span class="line">userChan = make(chan interface&#123;&#125;, 10)  // make初始化，大小为10</span><br><span class="line"></span><br><span class="line">var readOnlyChan &lt;-chan int            // 只读chan</span><br><span class="line">var writeOnlyChan chan&lt;- int           // 只写chan</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//chan放取数据</span><br><span class="line">userChan &lt;- &quot;nick&quot;</span><br><span class="line">name := &lt;- userChan</span><br><span class="line">name, ok := &lt;- userChan</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//关闭chan</span><br><span class="line">intChan := make(chan int, 1)</span><br><span class="line">intChan &lt;- 9</span><br><span class="line">close(intChan)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// range chan</span><br><span class="line">intChan := make(chan int, 10)</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    intChan &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">close(intChan)</span><br><span class="line"></span><br><span class="line">for v := range intChan &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="放入chan数据个数超过初始化指定大小会怎样？"><a href="#放入chan数据个数超过初始化指定大小会怎样？" class="headerlink" title="放入chan数据个数超过初始化指定大小会怎样？"></a>放入chan数据个数超过初始化指定大小会怎样？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userChan := make(chan interface&#123;&#125;)</span><br><span class="line">userChan &lt;- &quot;nick&quot;</span><br><span class="line">// 错误！fatal error: all goroutines are asleep - deadlock!</span><br><span class="line">// 开启race会一直阻塞</span><br></pre></td></tr></table></figure>
<p>开启一个goroutine来放入初始化未指定大小的chan不会报错。<br>即放即走，在等放入时有来拿数据的，就直接拿走。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">userChan := make(chan interface&#123;&#125;)</span><br><span class="line">go func() &#123;</span><br><span class="line">    userChan &lt;- &quot;nick&quot;</span><br><span class="line">&#125;()</span><br><span class="line">name := &lt;- userChan</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">userChan := make(chan interface&#123;&#125;)</span><br><span class="line">go func() &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        userChan &lt;- &quot;nick&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line">for &#123;</span><br><span class="line">    name := &lt;- userChan</span><br><span class="line">    fmt.Println(name)</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="chan关闭与不关闭"><a href="#chan关闭与不关闭" class="headerlink" title="chan关闭与不关闭"></a>chan关闭与不关闭</h3><p>关闭chan后再放入数据会 panic: send on closed channel。</p>
<p>chan不关闭取超数据的情况会报 deadlock</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    intChan := make(chan int, 10)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        intChan &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    for &#123;</span><br><span class="line">        //十次后 fatal error: all goroutines are asleep - deadlock!</span><br><span class="line">        i := &lt;- intChan</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="chan关闭的情况取超出值为类型默认值，如int为0"><a href="#chan关闭的情况取超出值为类型默认值，如int为0" class="headerlink" title="chan关闭的情况取超出值为类型默认值，如int为0"></a>chan关闭的情况取超出值为类型默认值，如int为0</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    intChan := make(chan int, 10)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        intChan &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    close(intChan)</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        i := &lt;- intChan</span><br><span class="line">        //十次后i值都为0，不报错</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断chan是否取完"><a href="#判断chan是否取完" class="headerlink" title="判断chan是否取完"></a>判断chan是否取完</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    intChan := make(chan int, 10)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        intChan &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    close(intChan)</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        i, ok := &lt;- intChan</span><br><span class="line">        if !ok &#123;</span><br><span class="line">            fmt.Println(&quot;channel is close.&quot;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="channel-例子"><a href="#channel-例子" class="headerlink" title="channel 例子"></a>channel 例子</h3><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func sendData(ch chan&lt;- string) &#123;</span><br><span class="line">    ch &lt;- &quot;go&quot;</span><br><span class="line">    ch &lt;- &quot;java&quot;</span><br><span class="line">    ch &lt;- &quot;c&quot;</span><br><span class="line">    ch &lt;- &quot;c++&quot;</span><br><span class="line">    ch &lt;- &quot;python&quot;</span><br><span class="line">    close(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getData(ch &lt;-chan string, chColse chan bool) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        str, ok := &lt;-ch</span><br><span class="line">        if !ok &#123;</span><br><span class="line">            fmt.Println(&quot;chan is close.&quot;)</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(str)</span><br><span class="line">    &#125;</span><br><span class="line">    chColse &lt;- true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan string, 10)</span><br><span class="line">    chColse := make(chan bool, 1)</span><br><span class="line">    go sendData(ch)</span><br><span class="line">    go getData(ch, chColse)</span><br><span class="line">    &lt;-chColse</span><br><span class="line">    close(chColse)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例子2-：interface类型chan，取出后转化为对应类型。"><a href="#例子2-：interface类型chan，取出后转化为对应类型。" class="headerlink" title="例子2 ：interface类型chan，取出后转化为对应类型。"></a>例子2 ：interface类型chan，取出后转化为对应类型。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type user struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    userChan := make(chan interface&#123;&#125;, 1)</span><br><span class="line"></span><br><span class="line">    u := user&#123;Name: &quot;nick&quot;&#125;</span><br><span class="line">    userChan &lt;- &amp;u</span><br><span class="line">    close(userChan)</span><br><span class="line"></span><br><span class="line">    var u1 interface&#123;&#125;</span><br><span class="line">    u1 = &lt;-userChan</span><br><span class="line"></span><br><span class="line">    var u2 *user</span><br><span class="line">    u2, ok := u1.(*user)</span><br><span class="line">    if !ok &#123;</span><br><span class="line">        fmt.Println(&quot;cant not convert.&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(u2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="channel-超时处理"><a href="#channel-超时处理" class="headerlink" title="channel 超时处理"></a>channel 超时处理</h3><p>利用select来处理chan超时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    case v := &lt;-chan1:</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    case v := &lt;-chan2:</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    default:</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(&quot;timeout...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>time.After()定时器来做处理。</p>
<p>在time.After()计时器触发之前，底层计时器不会被垃圾收集器回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case m := &lt;-c:</span><br><span class="line">    handle(m)</span><br><span class="line">case &lt;-time.After(5 * time.Minute):</span><br><span class="line">    fmt.Println(&quot;timed out&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t := time.NewTicker(time.Second)</span><br><span class="line">    fmt.Println(t)</span><br><span class="line">    for v := range t.C &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">    t.Stop()</span><br></pre></td></tr></table></figure>
<h3 id="Goroutine-Channel-例子"><a href="#Goroutine-Channel-例子" class="headerlink" title="Goroutine+Channel 例子"></a>Goroutine+Channel 例子</h3><h3 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h3><p>多个goroutine处理任务；</p>
<p>等待一组channel的返回结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">func calc(taskChan, resChan chan int, exitChan chan bool) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        err := recover()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;error...&quot;)</span><br><span class="line">            return </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    for v := range taskChan &#123;</span><br><span class="line">        // 任务处理逻辑</span><br><span class="line">        flag := true</span><br><span class="line">        for i := 2; i &lt; v; i++ &#123;</span><br><span class="line">            if v%i == 0 &#123;</span><br><span class="line">                flag = false</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if flag &#123;</span><br><span class="line">            //结果进chan</span><br><span class="line">            resChan &lt;- v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //处理完进退出chan</span><br><span class="line">    exitChan &lt;- true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    //任务chan</span><br><span class="line">    intChan := make(chan int, 1000)</span><br><span class="line">    //结果chan</span><br><span class="line">    resChan := make(chan int, 1000)</span><br><span class="line">    //退出chan</span><br><span class="line">    exitChan := make(chan bool, 8)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        for i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">            intChan &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        close(intChan)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    //启动8个goroutine做任务</span><br><span class="line">    for i := 0; i &lt; 8; i++ &#123;</span><br><span class="line">        go calc(intChan, resChan, exitChan)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        //等所有goroutine结束</span><br><span class="line">        for i := 0; i &lt; 8; i++ &#123;</span><br><span class="line">            &lt;-exitChan</span><br><span class="line">        &#125;</span><br><span class="line">        close(resChan)</span><br><span class="line">        close(exitChan)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    for v := range resChan &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h3><p>等待一组channel的返回结果 sync.WaitGroup 的解决方法。</p>
<p>WaitGroup用于等待一组线程的结束。父线程调用Add方法来设定应等待的线程的数量。每个被等待的线程在结束时应调用Done方法。同时，主线程里可以调用Wait方法阻塞至所有线程结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func merge(cs &lt;-chan int) &lt;-chan int &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    out := make(chan int)</span><br><span class="line"></span><br><span class="line">    output := func(c &lt;-chan int) &#123;</span><br><span class="line">        for n := range c &#123;</span><br><span class="line">            out &lt;- n</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Add(len(cs))</span><br><span class="line"></span><br><span class="line">    for _, c := range cs &#123;</span><br><span class="line">        go output(c)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        close(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    return out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/21/GoroutineAndChannel/" data-id="cjjviflur001dp78oz2gkr26u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-构建微型区块链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/19/构建微型区块链/" class="article-date">
  <time datetime="2018-07-19T12:06:35.000Z" itemprop="datePublished">2018-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/19/构建微型区块链/">构建微型区块链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>经过一段时间对区块链理论知识的学习，了解到区块链中的每个区块的基本结构由区块头和区块体构成，并了解了其中每部分包含的结构。本文在理论学习的基础上通过Python语言动手实现一个微型的区块链系统。</p>
<p>在区块链中，每个区块都需要一个时间戳 (timestamp) 和一个可选的索引 (index)。在tinyblockchain中，我们会同时存储这两项。为了确保区块链的完整性，每个区块都需要有一个能够识别自身身份的哈希 (hash)。在比特币中，每个区块的哈希对区块索引、时间戳、数据和前一区块哈希所有内容的一个加密哈希。此外，数据可以是任何你想要存储的任何内容。</p>
<p>已经有了区块结构，但是我们构建的是一个区块链。所以，我们需要将区块添加到真正的链上。正如前文所说，每个区块都需要前一个区块的信息。如此一来，就出现了一个问题：区块链中的第一个区块是如何而来？ 第一个区块，或者一般叫做创始块(genesis block), 这是一个十分特殊的块。在很多情况下，它是通过手动或是一些特殊的逻辑添加到区块链中。</p>
<p>为简便起见，我们创建一个简单返回创世块的函数。创始块的索引为 0，有一个任意的数据值，一个属于 “前一个哈希” 参数的任意值。</p>
<p>现在我们已经创建一个创世块，接下来我们需要一个能够在区块链中生成后续区块的函数。这个函数接受区块链中的前一个区块作为参数，创建所要生成区块的数据，然后返回带有数据的新区块。当新区块对前面的区块信息进行哈希时，区块链的完整性将会得到进一步增强。如果我们不对以前的区块信息进行哈希，那么第三者就能够轻易地“篡改历史”，用一个他们自己的链替换我们的链。区块链的哈希就像是一个加密证明，它能够保证一旦一个区块被加入到区块链中，那么这个区块就永远无法被替换或者移除。</p>
<p>在我们的案例中，区块链其实仅仅是一个 Python 的列表。列表的第一个元素是创世块。当然了，我们需要增加后续区块。因为这只是一个极简的区块链模型，我们仅添加 20 个新的区块。可以通过一个循环来添加。</p>
<p>全部源码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib <span class="keyword">as</span> hasher</span><br><span class="line"><span class="keyword">import</span> datetime <span class="keyword">as</span> date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, index, timestamp, data, previous_hash)</span>:</span></span><br><span class="line">        self.index = index</span><br><span class="line">        self.timestamp = timestamp</span><br><span class="line">        self.data = data</span><br><span class="line">        self.previous_hash = previous_hash</span><br><span class="line">        self.hash = self.hash_block()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash_block</span><span class="params">(self)</span>:</span></span><br><span class="line">        sha = hasher.sha256()</span><br><span class="line">        sha.update(</span><br><span class="line">            bytes(</span><br><span class="line">                str(self.index) + str(self.timestamp) + str(self.data) + str(</span><br><span class="line">                    self.previous_hash), <span class="string">'utf-8'</span>))</span><br><span class="line">        <span class="keyword">return</span> sha.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_genesis_block</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#  Manually construct a block with index 0 and arbitrary previous hash</span></span><br><span class="line">    <span class="keyword">return</span> Block(<span class="number">0</span>, date.datetime.now(), <span class="string">"Genesis Block"</span>, <span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_block</span><span class="params">(last_block)</span>:</span></span><br><span class="line">    this_index = last_block.index + <span class="number">1</span></span><br><span class="line">    this_timestamp = date.datetime.now()</span><br><span class="line">    this_data = <span class="string">"Hey! I'm block "</span> + str(this_index)</span><br><span class="line">    this_hash = last_block.hash</span><br><span class="line">    <span class="keyword">return</span> Block(this_index, this_timestamp, this_data, this_hash)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#  Create the blockchain and add the genesis block</span></span><br><span class="line">    blockchain = [create_genesis_block()]</span><br><span class="line">    previous_block = blockchain[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  How many blocks should we add to the chain after the genesis block</span></span><br><span class="line">    num_of_blocks_to_add = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, num_of_blocks_to_add):</span><br><span class="line">        block_to_add = next_block(previous_block)</span><br><span class="line">        blockchain.append(block_to_add)</span><br><span class="line">        previous_block = block_to_add</span><br><span class="line">        <span class="comment">#  Tell everyone about it!</span></span><br><span class="line">        print(<span class="string">"Block #&#123;&#125; has been added to the "</span></span><br><span class="line">              <span class="string">"blockchain!"</span>.format(block_to_add.index))</span><br><span class="line">        print(<span class="string">"Hash: &#123;&#125;\n"</span>.format(block_to_add.hash))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行部分截图：<br><img src="http://ww1.sinaimg.cn/large/007330Aply1ftffkde631j31a00t6dq6.jpg" alt=""><br>可以看出我们的链已经如期工作了，第一条微型区块链正式完成！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/19/构建微型区块链/" data-id="cjjviflve002op78oemfspduq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blockchain/">blockchain</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-以太坊入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/17/以太坊入门/" class="article-date">
  <time datetime="2018-07-17T13:59:28.000Z" itemprop="datePublished">2018-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/17/以太坊入门/">以太坊入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://ww1.sinaimg.cn/large/007330Aply1ftd7rj1nckj30ww0q2anz.jpg" alt=""><br>以太坊是什么？</p>
<p>以太坊是运行在一个计算机网络中的软件，它确保数据以及称为智能合约的小程序可以在没有中心协调者的情况下被所有网络中的计算机复制和处理。以太坊的愿景是创建一个无法停止，抗屏蔽（审查）和自我维持的去中心化世界计算机。官方网址是<a href="&quot;https://www.ethereum.org&quot;">https://www.ethereum.org</a>。<br>它延伸了比特币的区块链概念：在全球范围的多个计算机上验证，存储，和复制交易数据（因此术语叫“分布式账本”）。以太坊（Ethereum）在这个概念上更进一步，使在全球范围的多个计算机上运行代码成为现实。<br>比特币用来分布式储存数据的，以太坊用来分布式储存数据并且计算。这些小型的电脑运行程序叫做智能合约，合约由参与者在他们自己的机器上通过一种称为 ”以太坊虚拟机“的操作系统运行。</p>
<p>如何运行以太坊？</p>
<p>要运行以太坊，你可以下载（或者自己编写如果有耐心的话）一些称为以太坊客户端的软件。类似BitTorrent或Bitcoin，以太坊客户端将通过网络连接其它运行了类似客户端软件的计算机并且通过他们开始下载以太坊区块链从而赶上进度。它也将独立的验证每个区块是否符合以太坊的规则。<br>以太坊客户端软件可以做什么？</p>
<p>你可以用来：<br>连接到以太坊网络<br>探索以太坊的区块链<br>创建新的交易和智能合约<br>运行智能合约<br>挖矿新的区块</p>
<p>通过运行以太坊虚拟机，你的计算机就变成了网络中的一个“节点”，并与其它节点一样具有同等地位的处理事务。记住在一个点对点的网络里，没有“核心”服务器并且任何一个计算机都拥有等同的权利和地位。</p>
<p>以太坊和比特币有哪些相似之处？</p>
<p>我认为理解以太坊最简单的方式就是探索它与相对简单的系统－比特币之间的相似和不同之处。那么它们有哪些相似之处呢？<br>以太坊有一条区块链</p>
<p>和比特币一样，以太坊有一条区块链，这里面包含有数据块（交易和智能合约）。这些区块由一些参与者创建或者说挖出，而其它参与者来验证它们。</p>
<p>你可以在这里查看以太坊区块链：<a href="https://etherscan.io" target="_blank" rel="noopener">https://etherscan.io</a><br>区块通过前一个区块的哈希或指纹形成一条链状结构。具体可以参见a gentle introduction to blockchain technology</p>
<p>以太坊是公开并且无需许可的</p>
<p>和比特币一样，以太坊的主网是一个公有的、无许可的网络，也就是说任何人都可以下载或编写软件来连接网络，可以开始创建交易以及智能合约并且验证它们，还可以进行挖矿等，这些操作都不需要在任何其它机构里注册或登录。</p>
<p>总的来讲，人们讨论以太坊时指的是公有的无许可的版本，即公有链。不过，与比特币一样，你可以通过稍微修改以太坊文件创建没有连接到公网上的私有网络。目前私有网络中的代币以及智能合约与公有网络不兼容。更多有关公开无许可公有链和私有许可链之间异同的问题，请参考 confused by blockchains? Revolution vs Evolution</p>
<p>以太坊是工作量证明（POW）挖矿</p>
<p>同比特币一样，矿工通过花费电力解开数学难题创建有效区块。以太坊的工作量证明算法称为Ethash，它与比特币的工作量证明稍微有些不同，这使得用普通硬件挖矿成为可能。以太坊的这种工作量证明算法降低了普遍用于比特币挖矿的特定硬件ASICs的效率。</p>
<p>关于更多挖矿的知识详见 a gentle introduction to bitcoin mining.<br>在以太坊的发展计划中，准备在未来称为Serenity的以太坊软件版本中，用一种叫做Casper的更节能的股权证明（POS）协议来取代当前大量耗费电能的工作量证明（POW）挖矿。</p>
<p>以太坊有一种内置的数字货币</p>
<p>以太坊里的代币叫做Ether，简称ETH。与BTC类似，这种加密货币可以用来与其它加密货币或其它法币进行交易。目前一个ETH的价格大概在13美元左右（2016年10月）。与BTC拥有者被记录在比特币区块链中一样，以太币ETH拥有者也被记录在以太坊区块链中，尽管在技术实现的方式上它们有些许不同。</p>
<p>想要更多的了解加密货币以及代币可以参考《一个数字代币的基础介绍》</p>
<p>以太坊与比特币有哪些不同点？</p>
<p>这一段讨论会包含更多的技术性，在许多方面会更加复杂。</p>
<p>以太坊的区块时间更短<br>与比特币区块的10分钟相比，以太坊区块间时间大约在14秒左右。这意味着，当你在比特币和以太坊中发起一笔交易，以太坊中的交易被记录入区块链中的速度快于比特币中交易被记录区块链中。你可以认为比特币写入数据库的时间平均为10分钟，而以太坊写入数据库的时间平均为14秒。<br>以太坊有更小的区块</p>
<p>在比特币中，目前最大区块的大小被限定为1M，而以太坊区块大小根据在上面运行的智能合约的复杂性决定－这叫做Gas限制，每个区块的最大值会根据情况稍微有所不同。目前以太坊中最大区块大小大约为1500000Gas。从一个帐户到另一个帐户的ETH基础交易或支付（并非智能合约）大约消耗21000Gas。故每个区块中大概可以放进70（1500000/21000）笔交易。在比特中目前每个区块中大概可以包含1500到2000笔交易。</p>
<p>目前大多数以太坊区块大小在2KB以下。</p>
<p>以太坊虚拟机上可以运行智能合约<br>相比比特币原始的脚本语言，在以太坊中用来部署代码以及运行智能合约的语言更高级，因此开发者们更熟悉。智能合约代码在一种被称为以太坊虚拟机的东西上运行，以太坊虚拟机分布在网络中所有参与者的计算机上运行着。如果你对微软Excel宏命令（Excel上运行的代码块）熟悉的话，类似地，智能合约可以认为是在以太坊虚拟机上运行的代码块。</p>
<p>在很多描述中，以太坊智能合约被称为是“图灵完备”的。这意味着它们是功能完备的，而且在任何其它程序语言中能够完成的计算都可以在这上面完成。</p>
<p>以太代币的发行</p>
<p><img src="http://ww1.sinaimg.cn/large/007330Aply1ftd7kevdilj30wy0lkafo.jpg" alt=""><br>以太代币是如何被发行或创造的？以太币与比特币之间最大的不同是，比特币的产量每4年减半，而以太币每年的产量则是固定的。（可能持续到serenity阶段）</p>
<p>以太币比比特币更复杂。概要地说，以太币的数量以这种形式存在：<br>Pre-mine（矿前） + Block rewards（区块奖励） + Uncle rewards（叔块奖励） + Uncle referencing rewards（叔块引用奖励）<br>挖矿前</p>
<p>2014年7月/8月间，为众筹大约发行了7200万以太币。这些币有的时候被称之为“矿前”。众筹阶段之后，以太币每年的产量被限制在7200万以太币的25%（每年以太币的矿产量，不高于1800万，除了一次性为crowdsale而发行的7200万以太币）<br>区块奖励</p>
<p>目前，每产生一个新区块就会产生5个新以太币。计算一下，如果每14秒挖出一个区块，一年有3150万秒（365x24x60x60），这意味着每年有225万个区块被挖出来。225万个区块，每个区块5个以太币，也就是每年会产出1130万个以太币。这个数字与低于1800万以太币产量的数字，吻合。<br>叔块奖励</p>
<p>事实上，数量可能会比上述数字稍多一些。有些区块被挖得稍晚一些，因此不能称为主区块链的组成部分。比特币称这类区块为“孤块”，并且完全舍弃它们。但是，以太币称它们为“ uncles”，并且在之后的区块中，可以引用它们。如果uncles在之后的区块链中作为叔块被引用，每个叔块会为挖矿者产出大约4.375个以太币（5个以太币奖励的8分之7）.这被称之为叔块奖励。目前每天有大约500个叔块被创建，为以太币的日产量链，额外加入2000个以太币（以这种速度，每年产量为70万以太币）<br>叔块引用奖励</p>
<p>还有更多：矿工每引用一个叔块，就得到了大约0.15个以太币（最多引用两个叔块）<br>这种定义有效区块，奖励矿工的模式称为“幽灵协议”（Greedy Heaviest-Observed Sub-Tree ）（GHOST是贪婪最被观察子树的字首）。</p>
<p>以太币产量未来的变化</p>
<p>以太坊出块机制从工作量证明（PoW）（包括幽灵发行规则）转换为股权证明（PoS）后，以太币的发行会有什么变化尚未有定论。股权证明机制将使用一个称为Casper的协议（是的，作为友好的幽灵。谁说cryptonerds没有幽默感来着？）在Casper协议下，以太币的发行率将大大低于幽灵协议下的发行率。<br>挖矿奖励</p>
<p>那么，矿工挖矿时会得到什么？</p>
<p>在比特币中，矿工将得到：</p>
<p>• 12.5个新比特币（目前实际情况请参考“a gentle introduction to bitcoin mining”）<br>加上<br>• 打包在区块中的交易所产生的交易费</p>
<p>在以太坊中，矿工将得到：<br>• 新的区块奖励的5个以太币（或者4.375个新的叔块奖励以太币），<br>加上<br>• 引用2个最近叔块的一丢丢奖励（1/32的区块奖励，也就是，每个叔块 1/32x5=0.15625个新以太币）<br>加上<br>• 在区块中运行合约的Gas<br>目前，每个区块平均的gas限量是1500000，区块网络中每个gas的平均价格是0.000000022个以太币，也就是说，一个矿工可能从一个“满的”区块中得到的gas奖励是0.033个以太币。注意合约中的gas是用现存的以太币支付的，而非新创造的以太币。</p>
<p>以太坊的其他部分：Swarm 和 Whisper<br>计算机需要有计算、储存数据、以及沟通交流的功能。如果以太坊想要实现它势不可挡，抗屏蔽（审查）、自我维持、去中心化的“世界”计算机的景愿，它需要以一种稳健，有效地方式做到上述三件事。以太坊虚拟机只是一个整体的一部分。</p>
<p>以太坊虚拟机是有运行合约逻辑的计算元件</p>
<p>这是不依赖于一个中心服务器的计算。</p>
<p>swarm是点对点文件共享，它与BitTorrent相似，但用以太币为微报酬作为激励。文件被分解成块，分配并被参与的志愿者们储存。那些为存储并为块提供服务的节点，从那些需要储存和检索数据服务的节点得到以太币作为补偿。</p>
<p>这是不依赖于中心服务器的文件存储。</p>
<p>whisper是一种信息检索协议，它允许节点间直接以一种安全的形式互发信息，并对第三方组织窥探者隐藏发送者和接收者的信息。</p>
<p>这是不依赖于一个中心服务器的通讯管理。</p>
<p>以太坊中的一些概念<br>智能合约</p>
<p>智能合约是一段存储在以太坊区块链上的简短计算机程序。用以太币可以激活或者运行这些代码。想对智能合约了解更多，请参考 a gentle introduction to smart contracts.</p>
<p>下面是一段摘自Wikipedia的智能合约实例：<br><img src="http://ww1.sinaimg.cn/large/007330Aply1ftd7lybov2j30vy0l2gvp.jpg" alt=""><br>在以太坊你可以新建一个包含一些代码的账户，在一次交易中把它上传到以太坊区块链上，这样你就创建了一个智能合约。一旦合约被上传，它会像自动唱机一样运转–当你想要运行它的时候你应该创建一个交易，向合约支付ETH，如果合约需要，你可能还要提供一些其他信息。<br>每个挖矿计算机会通过以太坊虚拟机在它们的计算机上运行智能合约，作为他们参与挖矿进程的一部分，然后得出一个输出的结论。理论上，如果没有人恶意操作，每个计算机在以太坊网络上会得出相同的结论因为它们运行着提供了相同信息的相同合约代码。<br>当一个区块产出，矿工会把这个区块公布到其余的网络中，其他的计算机会验证它们得到的结果相同，然后添加该区块到它们自己的区块链上。这就是以太坊区块链更新状态的方式。</p>
<p>账户</p>
<p>在比特币中，有一个概念叫做地址，比特币存储在这里–就像是一串比特币的银行账户数字。这个在以太坊中一般被称作账户，账户有两种类型：</p>
<p>只存储ETH的账户–这些账户和比特币地址类似有时被称作Externally Owned Accounts (EOAs)。你可以用私钥为交易签名来向这些账户支付ETH。<br>这里有一个存储ETH的账户实例：<a href="https://etherscan.io/address/0x2d7c76202834a11a99576acf2ca95a7e66928ba0" target="_blank" rel="noopener">https://etherscan.io/address/0x2d7c76202834a11a99576acf2ca95a7e66928ba0</a></p>
<p>不仅存储 ETH，同时也有可以运行的代码（智能合约）–这些智能合约可以通过一个交易发送ETH的到账户里。一旦智能合约被上传，它就在那里等待被激活。<br>这里有一个有智能合约的账户实例：<br><a href="https://etherscan.io/address/0xcbe1060ee68bc0fed3c00f13d6f110b7eb6434f6#code" target="_blank" rel="noopener">https://etherscan.io/address/0xcbe1060ee68bc0fed3c00f13d6f110b7eb6434f6#code</a><br>叔块和孤块：不太需要的区块</p>
<p>以太坊区块出块速度比比特币高得多（以太坊每小时250个区块vs比特币每小时6个区块）。区块出块速度越快，“区块冲突”发生的几率就越大-ie多个有效区块可以几乎同时被创建，但是它们中只有一个能加入主链。另外一个“损失”是，这些块里面的数据不会被认为是总账的一部分，即使这些交易理论上是有效的。在比特币里这些非主链区块被叫做孤块或孤儿区块，它们无论如何不会成为主链的一部分，也不会被后来的区块引用。</p>
<p>在以太坊它们被叫做叔块。叔块会被随后的一些区块参考（参考ETH发布的部分）尽管它们里面的数据不会用到，挖出它们的稍少的奖励仍然是有效的。</p>
<p>这达成了两个重要目的：<br>矿工仍然受到激励挖矿即使有很大可能挖到一个非主链区块（高速出块会导致更多的孤块或者叔块）。</p>
<p>通过认可花费在叔块上的能量增加了区块链的安全性。</p>
<p>Gas和Gas价格</p>
<p>当你激活一个智能合约的时候，你在要求整个网络内的每个矿工个体分别执行里面的运算。这会花费他们的时间和精力，Gas是你为这项服务向矿工们支付的机制。</p>
<p>报酬是小额的以太币，想要运行智能合约的人的需要支付报酬来使合约工作。类似于投放一个硬币到自动唱机里。</p>
<p>付款款项（单位以太币）＝ Gas数量（单位Gas） x Gas价格（单位以太币／Gas）<br>Gas数量</p>
<p>智能合约越复杂（计算步骤的数量和类型，占用的内存等），用来完成运行就需要越多Gas。类比自动唱机，歌曲的时间越长，音量越大，让它工作你需要支付的则越多。<br>Gas价格</p>
<p>任何特定的合约所需的运行合约的Gas数量是固定的，由合约的复杂度决定，而Gas价格由想运行合约的人规定，在他们提交运行合约请求的时候（有点类似于比特币的交易费）。每个矿工会根据Gas的价格的高低来决定他们是否想作为区块的一部分去运行此合约。如果你希望矿工运行你的合约，你最好提供高一点的Gas价格。在某种程度是这是一场基于合约运行有多愿意付费驱动下的竞价。<br>为什么需要Gas？</p>
<p>让智能合约花费Gas/以太币/钱可以防止人们随意激活合约， 解决了垃圾交易以及相关问题，如果运行智能合约免费，此类问题会发生。</p>
<p>以太币单位</p>
<p>就像1美元可以分成100美分，1BTC可以被分成100,000,000 聪（中本聪的聪），以太坊也有它自己的转换单位。</p>
<p>最小的单位是wei ，每个ETH有1,000,000,000,000,000,000wei 。还有一些中间单位：Finney, Szabo, Shannon, Babbage, Ada–全部以对加密货币或网络相关领域作出杰出贡献者命名。<br>Wei和Ether是两个最常用的单位。<br><img src="http://ww1.sinaimg.cn/large/007330Aply1ftd7o0ko8rj30wq0j2dnl.jpg" alt=""><br>智能合约语言：Solidity/Serpent，LLL</p>
<p>有三种常见的智能合约语言，这些语言可以被编译成智能合约运行在以太坊虚拟矿机上。它们是：</p>
<p>Solidity – 和Javascript语言类似。这是目前最受欢迎的和功能丰富的智能合约脚本语言。<br>Serpent – 和Python语言类似，在以太坊历史的早期受欢迎。<br>LLL (Lisp Like Language) – 和Lisp类似，只有在早期使用。它大概是最难用的。</p>
<p>以太坊软件:geth,eth,pyethapp</p>
<p>官方的以太坊客户端都是开源的–你可以查看它们背后的代码并且重构这些代码开发自己的版本。最受欢迎的客户端有：<br>geth (Go语言客户端） <a href="https://github.com/ethereum/go-ethereum" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum
</a><br>eth ( C++客户端) <a href="https://github.com/ethereum/cpp-ethereum" target="_blank" rel="noopener">https://github.com/ethereum/cpp-ethereum</a><br>pyethapp (Python客户端) <a href="https://github.com/ethereum/pyethapp" target="_blank" rel="noopener">https://github.com/ethereum/pyethapp
</a><br>这些都是基于命令行的程序（黑底绿字的那种），可以有更多好看易懂界面的软件。目前官方的最受欢迎的图形化软件是Mist(<a href="https://github.com/ethereum/mistMist" target="_blank" rel="noopener">https://github.com/ethereum/mistMist</a>运行在geth或eth的顶层。)，<br>所以，geth/eth是底层的东西，Mist是顶层优美的屏幕。</p>
<p>历史：以太坊时间轴</p>
<p>Vitalik Buterin在2013年末的白皮书中提出了以太坊的概念。这个概念最终由Dr. Gavin Wood完善并在2014年4月发表了技术性的黄皮书。从此，以太坊的发展就由一群开发者组成的社区管理。<br>在2014年7月和8月，社区发起了一个为了项目开发募资的众筹，2015年7月30日以太坊区块链正式启动。</p>
<p>以太坊众筹<br>开发团队通过在2014年的7月至8月期间线上销售ETH代币而筹得资金，人们可以通过支付比特币来兑换以太币，最初的固定兑换率为1个BTC等于2000个ETH。（现在2016年10月，1个BTC可以买到50个ETH。）</p>
<p>众筹参与者发送比特币到一个比特币地址并且收到一个以太坊钱包包含相对应购买到ETH的数量。技术细节可以在以太坊博客中找到<a href="https://blog.ethereum.org/2014/07/22/launching-the-ether-sale/" target="_blank" rel="noopener">https://blog.ethereum.org/2014/07/22/launching-the-ether-sale/</a><br>通过这种方式，超过60百万的以太币被买走，相当于大约31500个BTC，当时价值约为1800万美金。同时额外发行了20%的以太币（120万ETH）用以促进开发以及设立以太坊基金会。</p>
<p>软件发布代号：Frontier/Homestead/Metropolis / Serenity<br>这是为不同版本的以太坊软件取的昵称，就像苹果的OS X系列名称Mavericks, El Capitan, Sierra。<br>Olympic (testnet): 2015年5月发布的测试版本，使用的代币不与真实的以太币兼容。测试网与核心线上网络平行运行，这里开发者可以测试他们的代码。</p>
<p>Frontier: 2015年7月30日发布，初始的上线版本让人们可以挖矿获取以太币并且建立和运行合约。<br>Homestead:2016年3月14日发布，改变了一些协议使之更稳定。</p>
<p>Metropolis: 将在未来发布，从命令行到图形界面。</p>
<p>Serenity: 将在未来发布，从PoW转变到PoS（Casper）。</p>
<p>总结<br>以太坊开发团队的愿景是创建一个无法停止，抗屏蔽（审查）和自我维持的去中心化世界计算机，可以进行计算，储存数据，和通讯。</p>
<p>它有一个公开无许可的开源版本，源码的分叉以及复制版本经过调整已经被用于私有网络。公开和私有的版本分别试图解决不同的问题。</p>
<p>这个技术现阶段还不成熟，但当越多的人使用，测试，开发并建立，它将会进步并且变的更强壮。<br>以太坊是区块链领域里最激动人心的技术之一，值得你保持关注它的进展。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/17/以太坊入门/" data-id="cjjviflv9002fp78ol6hi2uar" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ethereum/">ethereum</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-404-左叶子之和" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/17/404-左叶子之和/" class="article-date">
  <time datetime="2018-07-17T08:40:34.000Z" itemprop="datePublished">2018-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/17/404-左叶子之和/">404.左叶子之和</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>计算给定二叉树的所有左叶子之和。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">  / \</span><br><span class="line"> 9  20</span><br><span class="line">   /  \</span><br><span class="line">  15   7</span><br></pre></td></tr></table></figure>
<p>在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p>
<p>题解：</p>
<ol>
<li>递归：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">        if (root == NULL)</span><br><span class="line">            return 0;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        if(root-&gt;left != NULL) &#123;</span><br><span class="line">            if (root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL)</span><br><span class="line">                sum += root-&gt;left-&gt;val;</span><br><span class="line">            else</span><br><span class="line">                sum += sumOfLeftLeaves(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        sum += sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>非递归</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">        if (root == NULL)</span><br><span class="line">            return 0;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        </span><br><span class="line">        //Here for each node in the tree we check whether its left child is a leaf. If it is true, we add its value to answer, otherwise add left child to the stack to process it later. For right child we add it to stack only if it is not a leaf.</span><br><span class="line">        </span><br><span class="line">        while (!s.empty()) &#123;</span><br><span class="line">            TreeNode* node = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            if (node-&gt;left != NULL) &#123;</span><br><span class="line">                if (node-&gt;left-&gt;left == NULL &amp;&amp; node-&gt;left-&gt;right == NULL)</span><br><span class="line">                    sum += node-&gt;left-&gt;val;</span><br><span class="line">                else</span><br><span class="line">                    s.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;right != NULL) &#123;</span><br><span class="line">                if (node-&gt;right-&gt;left != NULL || node-&gt;right-&gt;right != NULL)</span><br><span class="line">                    s.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/17/404-左叶子之和/" data-id="cjjviflul0012p78odu2ahwgv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tree/">tree</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-112-路径总和" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/17/112-路径总和/" class="article-date">
  <time datetime="2018-07-17T08:15:54.000Z" itemprop="datePublished">2018-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/17/112-路径总和/">112.路径总和</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">        / \</span><br><span class="line">       4   8</span><br><span class="line">      /   / \</span><br><span class="line">     11  13  4</span><br><span class="line">    /  \      \</span><br><span class="line">   7    2      1</span><br></pre></td></tr></table></figure>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
<p>题解：<br>//注意是根到“叶子”节点的路径！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        if (root == NULL)</span><br><span class="line">            return false;</span><br><span class="line">        if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)</span><br><span class="line">            return root-&gt;val == sum;</span><br><span class="line">        return hasPathSum(root-&gt;left, sum - (root-&gt;val)) || hasPathSum(root-&gt;right, sum - (root-&gt;val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/17/112-路径总和/" data-id="cjjviflu4000ap78oi8nm51xs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tree/">tree</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-110-平衡二叉树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/17/110-平衡二叉树/" class="article-date">
  <time datetime="2018-07-17T07:54:54.000Z" itemprop="datePublished">2018-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/17/110-平衡二叉树/">110.平衡二叉树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<p>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回 true 。</p>
<p>示例 2:</p>
<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>
<p>返回 false 。</p>
<p>题解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        if (root == NULL)</span><br><span class="line">            return true;</span><br><span class="line">        int leftHeight = height(root-&gt;left);</span><br><span class="line">        int rightHeight = height(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        return abs(leftHeight-rightHeight) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    int height(TreeNode* root) &#123;</span><br><span class="line">        if (root == NULL)</span><br><span class="line">            return 0;</span><br><span class="line">        return max(height(root-&gt;left), height(root-&gt;right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/17/110-平衡二叉树/" data-id="cjjviflu00005p78omjrkcbz2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tree/">tree</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-222-完全二叉树的节点个数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/17/222-完全二叉树的节点个数/" class="article-date">
  <time datetime="2018-07-17T07:29:41.000Z" itemprop="datePublished">2018-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/17/222-完全二叉树的节点个数/">222.完全二叉树的节点个数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>给出一个完全二叉树，求出该树的节点个数。</p>
<p>说明：</p>
<p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<p>示例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> / \  /</span><br><span class="line"><span class="number">4</span>  <span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>题解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = <span class="number">0</span>, rightDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode *node = root; node; node = node-&gt;left)</span><br><span class="line">            leftDepth++;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode *node = root; node; node = node-&gt;right)</span><br><span class="line">            rightDepth++;</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; leftDepth) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countNodes(root-&gt;left) + countNodes(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/17/222-完全二叉树的节点个数/" data-id="cjjviflud000np78o74apsue0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tree/">tree</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-101-对称二叉树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/17/101-对称二叉树/" class="article-date">
  <time datetime="2018-07-17T06:08:17.000Z" itemprop="datePublished">2018-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/17/101-对称二叉树/">101.对称二叉树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 	1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">  / \</span><br><span class="line"> 2   2</span><br><span class="line">  \   \</span><br><span class="line">  3    3</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p>
<p>题解：</p>
<ol>
<li>递归</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val != q-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(p-&gt;left, q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>非递归</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="built_in">queue</span>&lt;TreeNode *&gt; q1, q2;</span><br><span class="line">        q1.push(root-&gt;left);</span><br><span class="line">        q2.push(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span> (!q1.empty() &amp;&amp; !q2.empty()) &#123;</span><br><span class="line">            TreeNode* front1 = q1.front();</span><br><span class="line">            TreeNode* front2 = q2.front();</span><br><span class="line">            q1.pop();</span><br><span class="line">            q2.pop();</span><br><span class="line">            <span class="keyword">if</span> (front1 == <span class="literal">NULL</span> &amp;&amp; front2 == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (front1 == <span class="literal">NULL</span> || front2 == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (front1-&gt;val != front2-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q1.push(front1-&gt;left);</span><br><span class="line">            q1.push(front1-&gt;right);</span><br><span class="line">            q2.push(front2-&gt;right);</span><br><span class="line">            q2.push(front2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/17/101-对称二叉树/" data-id="cjjvifltu0001p78ow3xkehv0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tree/">tree</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-100-相同的树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/17/100-相同的树/" class="article-date">
  <time datetime="2018-07-17T05:44:59.000Z" itemprop="datePublished">2018-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/17/100-相同的树/">100.相同的树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (p == q);</span><br><span class="line">        <span class="keyword">return</span> ((p-&gt;val == q-&gt;val) &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/17/100-相同的树/" data-id="cjjvifltp0000p78ou69a2grd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tree/">tree</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-226-翻转二叉树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/17/226-翻转二叉树/" class="article-date">
  <time datetime="2018-07-17T05:37:01.000Z" itemprop="datePublished">2018-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/17/226-翻转二叉树/">226.翻转二叉树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	 4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        invertTree(root-&gt;left);</span><br><span class="line">        invertTree(root-&gt;right);</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/17/226-翻转二叉树/" data-id="cjjviflue000pp78o50a7r2px" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tree/">tree</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linked-List/">Linked List</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arrays/">arrays</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bitcoin/">bitcoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blockchain/">blockchain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cryptocurrency/">cryptocurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ethereum/">ethereum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hyperledger-fabric/">hyperledger-fabric</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stack-queue/">stack&&queue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tree/">tree</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/Linked-List/" style="font-size: 16.67px;">Linked List</a> <a href="/tags/arrays/" style="font-size: 20px;">arrays</a> <a href="/tags/bitcoin/" style="font-size: 10px;">bitcoin</a> <a href="/tags/blockchain/" style="font-size: 15px;">blockchain</a> <a href="/tags/cryptocurrency/" style="font-size: 10px;">cryptocurrency</a> <a href="/tags/ethereum/" style="font-size: 10px;">ethereum</a> <a href="/tags/golang/" style="font-size: 13.33px;">golang</a> <a href="/tags/hyperledger-fabric/" style="font-size: 10px;">hyperledger-fabric</a> <a href="/tags/leetcode/" style="font-size: 13.33px;">leetcode</a> <a href="/tags/stack-queue/" style="font-size: 11.67px;">stack&&queue</a> <a href="/tags/tree/" style="font-size: 18.33px;">tree</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/21/GoroutineAndChannel/">GoroutineAndChannel</a>
          </li>
        
          <li>
            <a href="/2018/07/19/构建微型区块链/">构建微型区块链</a>
          </li>
        
          <li>
            <a href="/2018/07/17/以太坊入门/">以太坊入门</a>
          </li>
        
          <li>
            <a href="/2018/07/17/404-左叶子之和/">404.左叶子之和</a>
          </li>
        
          <li>
            <a href="/2018/07/17/112-路径总和/">112.路径总和</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>