<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>GoroutineAndChannel | Always Be Coding</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Go语言的主要的功能在于令人简易使用的并行设计，这个方法叫做Goroutine，通过Goroutine能够让你的程序以异步的方式运行，而不需要担心一个函数导致程序中断，因此Go语言也非常地适合网络服务。 我们通过go让其中一个函数同步运行，如此就不需要等待该函数运行完后才能运行下一个函数。 12345func main() &amp;#123;    // 通过 `go`，我们可以把这个函数异步执行，这样">
<meta name="keywords" content="golang">
<meta property="og:type" content="article">
<meta property="og:title" content="GoroutineAndChannel">
<meta property="og:url" content="http://yoursite.com/2018/07/21/GoroutineAndChannel/index.html">
<meta property="og:site_name" content="Always Be Coding">
<meta property="og:description" content="Go语言的主要的功能在于令人简易使用的并行设计，这个方法叫做Goroutine，通过Goroutine能够让你的程序以异步的方式运行，而不需要担心一个函数导致程序中断，因此Go语言也非常地适合网络服务。 我们通过go让其中一个函数同步运行，如此就不需要等待该函数运行完后才能运行下一个函数。 12345func main() &amp;#123;    // 通过 `go`，我们可以把这个函数异步执行，这样">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-07-21T14:29:48.038Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GoroutineAndChannel">
<meta name="twitter:description" content="Go语言的主要的功能在于令人简易使用的并行设计，这个方法叫做Goroutine，通过Goroutine能够让你的程序以异步的方式运行，而不需要担心一个函数导致程序中断，因此Go语言也非常地适合网络服务。 我们通过go让其中一个函数同步运行，如此就不需要等待该函数运行完后才能运行下一个函数。 12345func main() &amp;#123;    // 通过 `go`，我们可以把这个函数异步执行，这样">
  
    <link rel="alternate" href="/atom.xml" title="Always Be Coding" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Always Be Coding</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-GoroutineAndChannel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/21/GoroutineAndChannel/" class="article-date">
  <time datetime="2018-07-21T14:17:11.000Z" itemprop="datePublished">2018-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      GoroutineAndChannel
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Go语言的主要的功能在于令人简易使用的并行设计，这个方法叫做Goroutine，通过Goroutine能够让你的程序以异步的方式运行，而不需要担心一个函数导致程序中断，因此Go语言也非常地适合网络服务。</p>
<p>我们通过go让其中一个函数同步运行，如此就不需要等待该函数运行完后才能运行下一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // 通过 `go`，我们可以把这个函数异步执行，这样就不会阻塞往下执行。</span><br><span class="line">    go loop()</span><br><span class="line">    // 执行 Other</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Goroutine是类似线程的概念（但Goroutine并不是线程）。线程属于系统层面，通常来说创建一个新的线程会消耗较多的资源且管理不易。而 Goroutine就像轻量级的线程，但我们称其为并发，一个Go程序可以运行超过数万个 Goroutine，并且这些性能都是原生级的，随时都能够关闭、结束。一个核心里面可以有多个Goroutine，通过GOMAXPROCS参数你能够限制Gorotuine可以占用几个系统线程来避免失控。</p>
<p>在内置的官方包中也不时能够看见Goroutine的应用，像是net/http中用来监听网络服务的函数实际上是创建一个不断运行循环的Goroutine。</p>
<h3 id="设置同时执行的cpu数（GOMAXPROCS）"><a href="#设置同时执行的cpu数（GOMAXPROCS）" class="headerlink" title="设置同时执行的cpu数（GOMAXPROCS）"></a>设置同时执行的cpu数（GOMAXPROCS）</h3><p>GOMAXPROCS 在调度程序优化后会去掉，默认用系统所有资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    num := runtime.NumCPU()    //本地机器的逻辑CPU个数</span><br><span class="line">    runtime.GOMAXPROCS(num)    //设置可同时执行的最大CPU数，并返回先前的设置</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Goroutine中使用recover"><a href="#Goroutine中使用recover" class="headerlink" title="Goroutine中使用recover"></a>Goroutine中使用recover</h3><p>应用场景，如果某个goroutine panic了，而且这个goroutine里面没有捕获(recover)，那么整个进程就会挂掉。所以，好的习惯是每当go产生一个goroutine，就需要写下recover。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    domainSyncChan = make(chan int, 10)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func domainPut(num int) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        err := recover()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;error to chan put.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    domainSyncChan &lt;- num</span><br><span class="line">    </span><br><span class="line">    panic(&quot;error....&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        domainName := i</span><br><span class="line">        go domainPut(domainName)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second * 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Goroutine-例子"><a href="#Goroutine-例子" class="headerlink" title="Goroutine 例子"></a>Goroutine 例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    m    = make(map[int]uint64)</span><br><span class="line">    lock sync.Mutex //申明一个互斥锁</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type task struct &#123;</span><br><span class="line">    n int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func calc(t *task) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        err := recover()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;error...&quot;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    var sum uint64</span><br><span class="line">    sum = 1</span><br><span class="line">    for i := 1; i &lt; t.n; i++ &#123;</span><br><span class="line">        sum *= uint64(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock.Lock() //写全局数据加互斥锁</span><br><span class="line">    m[t.n] = sum</span><br><span class="line">    lock.Unlock() //解锁</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        t := &amp;task&#123;n: i&#125;</span><br><span class="line">        go calc(t) // Goroutine来执行任务</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second) // Goroutine异步，所以等一秒到任务完成</span><br><span class="line"></span><br><span class="line">    lock.Lock() //读全局数据加锁</span><br><span class="line">    for k, v := range m &#123;</span><br><span class="line">        fmt.Printf(&quot;%d! = %v\n&quot;, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(len(m))</span><br><span class="line">    lock.Unlock() //解锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Goroutine-例子（等待所有任务退出主程序再退出）"><a href="#Goroutine-例子（等待所有任务退出主程序再退出）" class="headerlink" title="Goroutine 例子（等待所有任务退出主程序再退出）"></a>Goroutine 例子（等待所有任务退出主程序再退出）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func calc(w *sync.WaitGroup, i int)  &#123;</span><br><span class="line">    fmt.Println(&quot;calc: &quot;, i)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    w.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    for i:=0; i&lt;10; i++ &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go calc(&amp;wg, i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(&quot;all goroutine finish&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>channel，管道、队列，先进先出，用来异步传递数据。channel加上goroutine，就形成了一种既简单又强大的请求处理模型，使高并发和线程同步之间代码的编写变得异常简单。</p>
<p>线程安全，多个goroutine同时访问，不需要加锁。</p>
<p>channel是有类型的，一个整数的channel只能存放整数。</p>
<h3 id="channel使用"><a href="#channel使用" class="headerlink" title="channel使用"></a>channel使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//chan申明</span><br><span class="line">var userChan chan interface&#123;&#125;          // chan里面放interface类型</span><br><span class="line">userChan = make(chan interface&#123;&#125;, 10)  // make初始化，大小为10</span><br><span class="line"></span><br><span class="line">var readOnlyChan &lt;-chan int            // 只读chan</span><br><span class="line">var writeOnlyChan chan&lt;- int           // 只写chan</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//chan放取数据</span><br><span class="line">userChan &lt;- &quot;nick&quot;</span><br><span class="line">name := &lt;- userChan</span><br><span class="line">name, ok := &lt;- userChan</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//关闭chan</span><br><span class="line">intChan := make(chan int, 1)</span><br><span class="line">intChan &lt;- 9</span><br><span class="line">close(intChan)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// range chan</span><br><span class="line">intChan := make(chan int, 10)</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    intChan &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">close(intChan)</span><br><span class="line"></span><br><span class="line">for v := range intChan &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="放入chan数据个数超过初始化指定大小会怎样？"><a href="#放入chan数据个数超过初始化指定大小会怎样？" class="headerlink" title="放入chan数据个数超过初始化指定大小会怎样？"></a>放入chan数据个数超过初始化指定大小会怎样？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userChan := make(chan interface&#123;&#125;)</span><br><span class="line">userChan &lt;- &quot;nick&quot;</span><br><span class="line">// 错误！fatal error: all goroutines are asleep - deadlock!</span><br><span class="line">// 开启race会一直阻塞</span><br></pre></td></tr></table></figure>
<p>开启一个goroutine来放入初始化未指定大小的chan不会报错。<br>即放即走，在等放入时有来拿数据的，就直接拿走。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">userChan := make(chan interface&#123;&#125;)</span><br><span class="line">go func() &#123;</span><br><span class="line">    userChan &lt;- &quot;nick&quot;</span><br><span class="line">&#125;()</span><br><span class="line">name := &lt;- userChan</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">userChan := make(chan interface&#123;&#125;)</span><br><span class="line">go func() &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        userChan &lt;- &quot;nick&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line">for &#123;</span><br><span class="line">    name := &lt;- userChan</span><br><span class="line">    fmt.Println(name)</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="chan关闭与不关闭"><a href="#chan关闭与不关闭" class="headerlink" title="chan关闭与不关闭"></a>chan关闭与不关闭</h3><p>关闭chan后再放入数据会 panic: send on closed channel。</p>
<p>chan不关闭取超数据的情况会报 deadlock</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    intChan := make(chan int, 10)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        intChan &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    for &#123;</span><br><span class="line">        //十次后 fatal error: all goroutines are asleep - deadlock!</span><br><span class="line">        i := &lt;- intChan</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="chan关闭的情况取超出值为类型默认值，如int为0"><a href="#chan关闭的情况取超出值为类型默认值，如int为0" class="headerlink" title="chan关闭的情况取超出值为类型默认值，如int为0"></a>chan关闭的情况取超出值为类型默认值，如int为0</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    intChan := make(chan int, 10)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        intChan &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    close(intChan)</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        i := &lt;- intChan</span><br><span class="line">        //十次后i值都为0，不报错</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断chan是否取完"><a href="#判断chan是否取完" class="headerlink" title="判断chan是否取完"></a>判断chan是否取完</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    intChan := make(chan int, 10)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        intChan &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    close(intChan)</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        i, ok := &lt;- intChan</span><br><span class="line">        if !ok &#123;</span><br><span class="line">            fmt.Println(&quot;channel is close.&quot;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="channel-例子"><a href="#channel-例子" class="headerlink" title="channel 例子"></a>channel 例子</h3><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func sendData(ch chan&lt;- string) &#123;</span><br><span class="line">    ch &lt;- &quot;go&quot;</span><br><span class="line">    ch &lt;- &quot;java&quot;</span><br><span class="line">    ch &lt;- &quot;c&quot;</span><br><span class="line">    ch &lt;- &quot;c++&quot;</span><br><span class="line">    ch &lt;- &quot;python&quot;</span><br><span class="line">    close(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getData(ch &lt;-chan string, chColse chan bool) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        str, ok := &lt;-ch</span><br><span class="line">        if !ok &#123;</span><br><span class="line">            fmt.Println(&quot;chan is close.&quot;)</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(str)</span><br><span class="line">    &#125;</span><br><span class="line">    chColse &lt;- true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan string, 10)</span><br><span class="line">    chColse := make(chan bool, 1)</span><br><span class="line">    go sendData(ch)</span><br><span class="line">    go getData(ch, chColse)</span><br><span class="line">    &lt;-chColse</span><br><span class="line">    close(chColse)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例子2-：interface类型chan，取出后转化为对应类型。"><a href="#例子2-：interface类型chan，取出后转化为对应类型。" class="headerlink" title="例子2 ：interface类型chan，取出后转化为对应类型。"></a>例子2 ：interface类型chan，取出后转化为对应类型。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type user struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    userChan := make(chan interface&#123;&#125;, 1)</span><br><span class="line"></span><br><span class="line">    u := user&#123;Name: &quot;nick&quot;&#125;</span><br><span class="line">    userChan &lt;- &amp;u</span><br><span class="line">    close(userChan)</span><br><span class="line"></span><br><span class="line">    var u1 interface&#123;&#125;</span><br><span class="line">    u1 = &lt;-userChan</span><br><span class="line"></span><br><span class="line">    var u2 *user</span><br><span class="line">    u2, ok := u1.(*user)</span><br><span class="line">    if !ok &#123;</span><br><span class="line">        fmt.Println(&quot;cant not convert.&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(u2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="channel-超时处理"><a href="#channel-超时处理" class="headerlink" title="channel 超时处理"></a>channel 超时处理</h3><p>利用select来处理chan超时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    case v := &lt;-chan1:</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    case v := &lt;-chan2:</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    default:</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(&quot;timeout...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>time.After()定时器来做处理。</p>
<p>在time.After()计时器触发之前，底层计时器不会被垃圾收集器回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case m := &lt;-c:</span><br><span class="line">    handle(m)</span><br><span class="line">case &lt;-time.After(5 * time.Minute):</span><br><span class="line">    fmt.Println(&quot;timed out&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t := time.NewTicker(time.Second)</span><br><span class="line">    fmt.Println(t)</span><br><span class="line">    for v := range t.C &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">    t.Stop()</span><br></pre></td></tr></table></figure>
<h3 id="Goroutine-Channel-例子"><a href="#Goroutine-Channel-例子" class="headerlink" title="Goroutine+Channel 例子"></a>Goroutine+Channel 例子</h3><h3 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h3><p>多个goroutine处理任务；</p>
<p>等待一组channel的返回结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">func calc(taskChan, resChan chan int, exitChan chan bool) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        err := recover()</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;error...&quot;)</span><br><span class="line">            return </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    for v := range taskChan &#123;</span><br><span class="line">        // 任务处理逻辑</span><br><span class="line">        flag := true</span><br><span class="line">        for i := 2; i &lt; v; i++ &#123;</span><br><span class="line">            if v%i == 0 &#123;</span><br><span class="line">                flag = false</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if flag &#123;</span><br><span class="line">            //结果进chan</span><br><span class="line">            resChan &lt;- v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //处理完进退出chan</span><br><span class="line">    exitChan &lt;- true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    //任务chan</span><br><span class="line">    intChan := make(chan int, 1000)</span><br><span class="line">    //结果chan</span><br><span class="line">    resChan := make(chan int, 1000)</span><br><span class="line">    //退出chan</span><br><span class="line">    exitChan := make(chan bool, 8)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        for i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">            intChan &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        close(intChan)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    //启动8个goroutine做任务</span><br><span class="line">    for i := 0; i &lt; 8; i++ &#123;</span><br><span class="line">        go calc(intChan, resChan, exitChan)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        //等所有goroutine结束</span><br><span class="line">        for i := 0; i &lt; 8; i++ &#123;</span><br><span class="line">            &lt;-exitChan</span><br><span class="line">        &#125;</span><br><span class="line">        close(resChan)</span><br><span class="line">        close(exitChan)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    for v := range resChan &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h3><p>等待一组channel的返回结果 sync.WaitGroup 的解决方法。</p>
<p>WaitGroup用于等待一组线程的结束。父线程调用Add方法来设定应等待的线程的数量。每个被等待的线程在结束时应调用Done方法。同时，主线程里可以调用Wait方法阻塞至所有线程结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func merge(cs &lt;-chan int) &lt;-chan int &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    out := make(chan int)</span><br><span class="line"></span><br><span class="line">    output := func(c &lt;-chan int) &#123;</span><br><span class="line">        for n := range c &#123;</span><br><span class="line">            out &lt;- n</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Add(len(cs))</span><br><span class="line"></span><br><span class="line">    for _, c := range cs &#123;</span><br><span class="line">        go output(c)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        close(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    return out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/21/GoroutineAndChannel/" data-id="cjjviflur001dp78oz2gkr26u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/07/19/构建微型区块链/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">构建微型区块链</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linked-List/">Linked List</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arrays/">arrays</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bitcoin/">bitcoin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blockchain/">blockchain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cryptocurrency/">cryptocurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ethereum/">ethereum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hyperledger-fabric/">hyperledger-fabric</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stack-queue/">stack&&queue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tree/">tree</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/Linked-List/" style="font-size: 16.67px;">Linked List</a> <a href="/tags/arrays/" style="font-size: 20px;">arrays</a> <a href="/tags/bitcoin/" style="font-size: 10px;">bitcoin</a> <a href="/tags/blockchain/" style="font-size: 15px;">blockchain</a> <a href="/tags/cryptocurrency/" style="font-size: 10px;">cryptocurrency</a> <a href="/tags/ethereum/" style="font-size: 10px;">ethereum</a> <a href="/tags/golang/" style="font-size: 13.33px;">golang</a> <a href="/tags/hyperledger-fabric/" style="font-size: 10px;">hyperledger-fabric</a> <a href="/tags/leetcode/" style="font-size: 13.33px;">leetcode</a> <a href="/tags/stack-queue/" style="font-size: 11.67px;">stack&&queue</a> <a href="/tags/tree/" style="font-size: 18.33px;">tree</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/21/GoroutineAndChannel/">GoroutineAndChannel</a>
          </li>
        
          <li>
            <a href="/2018/07/19/构建微型区块链/">构建微型区块链</a>
          </li>
        
          <li>
            <a href="/2018/07/17/以太坊入门/">以太坊入门</a>
          </li>
        
          <li>
            <a href="/2018/07/17/404-左叶子之和/">404.左叶子之和</a>
          </li>
        
          <li>
            <a href="/2018/07/17/112-路径总和/">112.路径总和</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>